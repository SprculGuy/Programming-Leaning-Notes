Brenden Ike in 1995 (Internationally standard for JavaScript language = ECMAScript) (European Computer Manufacture Association) 
                                                        ECMAScript is the specification describing how browsers should implement and interpret JavaScript.
            ES 5 -> 2009
            ES 6 -> 2015   Biggest update after which every year JS gets updates
            JS is Backward compatible, even with ES1(1997)

            Js is functionality/behavior for Components of webpage



** Characteristics of Js
            High Level - no need to manage memory with variable definition as c/c++
            garbage collection
            Just in time compiled (compiles and executed immediately)
            multi paradigm (can be imperative or declarative paradigm) - supports procedural/function/object-oriented paradigm
            Synchronous
            Single threaded
            Prototyped based oopl(has no class, object is inherited from another object(prototype object))
            dynamically typed

            First-class function(function can be treated as variable) 
            Non-blocking event loop concurrency model(lets user to executes time-consuming tasks in background and takes them back in main thread as they finished)
			Everything in js happens inside an Execution Context


* Typescript  - JavaScript's superset with additional feature implementation(script.ts)
                - TypeScript adds static typing to JavaScript, which can help catch errors during development and improve code maintainability.
                - Needs TypeScript compiler (tsc) to transpile it into JavaScript.


* JavaScript framework
            ReactJS - use JSX(JavaScript XML) which simplifies mixing of js and html
            vueJS - 
            AngularJS -
        native mobile applications    
            React Native - 
            Ionic -        
        Native Desktop Application
            Electron - Electron embeds Chromium and Node.js to enable web developers to create Cross Platform desktop applications.


* JavaScript Build tools - comes js framework with to convert/optimize the code back into js for current browser
                            - converting ES6+ JavaScript to older versions for broader browser compatibility using 'Babel'
            1. npm - comes with Node.js    Node.js is to execute JavaScript code server-side
            2. webpack
            3. gulp    



** Types to apply JS/Script to webpage -    
    1> Internal - used anywhere inside the <html> and only applies to current html document
            <script>
                const allp = document.querySelectorAll("p")             // ; at ending is optional
                                                                        // '' or " " either can be used according to our preference.
                for(let item of allp){
                    item.innerHTML = "item.innerHTML"
                }
            </script>

    2> External -
            <script src="js/script.js"></script>            // scripts fetched and executed in priority by halting the document(html/css) loading. i.e why should be used at the end of Body tag/element

        or  <script defer src="js/script.js"></script>      // scripts are fetched parallel to document but executed only after loading of document is finished. 
                                                            // 'DOMContentLoaded' event only fires after script execution(even if document fetched completely before script fetched/executed), 
                                                            // scripts are executed in order they are declared in code

        or  <script async src="js/hello-world-alert.js"> alert("Hi") </script>      // only the external js code will be executed, internal js will be ignored
                                                            // scripts fetched parallel to document and executed after fetched by halting the document loading. 
                                                            // 'DOMContentLoaded' event fires as soon as document fetched completely(even if script fetched/execution is not complete)
                                                            // scripts not guaranteed to execute in order they are declared in code, scripts get executed in the order it is fetched

            <script type="module" src="js/script.js"></script>      // when type attribute set to module, script tag get automatically becomes defer


    Note - in case of multiple script imports in html
            i.e.    <script defer src="js/script1.js"></script>
                    <script defer src="js/script2.js"></script>

                All the global attributes inside "script1.js" will be accessible in "script2.js" as "script2.js" is imported after "script1.js"
                Attributes(Global) inside "script2.js" will not be accessible in "script1.js" as "script1.js" is imported before "script2.js"



** Execution of JS-->                                                
	SourceCode -> Parsing & syntax Checker -> AST -> Just in-Time Compilation(BrowserEngine/node) -> Machine language -> Execution(using call stack) -> Global Execution Context + EC of function as they were called + EC of callback function after using event loop             
												 ↗     Gives unoptimized version for execution as fast as possible 		↘
												 ↖________ then in background the code is optimized(recompiled) ________↙                
		- Uses 3 separate threads(Parsing,compilation,optimization) which are completely separate from the main thread which is running into the call stack executing code.
    1. Parsed(analyzing and converting a program into an internal format that a runtime environment can actually run) into a data structure called AST(Abstract Syntax Tree)
                    AST example for code; const x = 23;
                        VariableDeclaration { 
                            start: 0
                            end: 13
                            declarations: [
                                variableDeclarator {
                                    start: 6
                                    end: 12
                                    id: Identifier {
                                        start:6
                                        end: 7
                                        name: "x"
                                    }
                                    init: Literal = $node {
                                        start: 10
                                        end: 12
                                        value: 23
                                        raw: "23"
                                    }
                                }
                            ]
                            kind: "const"
                        }
	2. AST is compiled and converted as well as executed immediately, an unoptimized version of machine code for fast execution.
	3. Then the unoptimized machine code is recompiled again and again without stopping already running execution to make the machine code optimized(inlining, copy elision, inline caching)
	4. Parsing, Compilation/Recompilation & and Optimization is done on separate threads which is completely separate from the main thread
	5. Main thread swept away old unoptimized code and re-executes new optimized machine code again and again
    6. After getting the Machine Code, one "Global Execution Context" is created(for code outside of any Function) and JS code is executed inside call stack
    7. as the function call is executed, new function specific execution context is created and added to call stack of JS engine
    8. After execution of top-level JS code, "Global Execution Context" pops off the call stack.
	9. As call stack becomes free, all queued the callback functions(oldest first) execution contexts are created and those functions are executed inside of respective execution contexts



** JavaScript Runtime in Browser -

    +----------------------------------------------------------------------------+
    |                           JS Runtime in Browser                            |
    |                                                                            |
    | +---------------------------+   +--------------------------------------- + |
    | |         JS Engine         |   |               Web APIs                 | |     	- Web APIs is the functionalities provided to the JS engine accessible on windows object  
    | |     Code                  |   |  +--------+  +----------+  +-----+     | |     	- Web APIs are not the part of JS language, but the part of JS Runtime
    | |Parser⬇  ⬆⬇ Optimization   |   |  |document|  |setTimeout|  |fetch| ... | |     	- All Asynchronous tasks are executed in Web APIs environment before passing to Microtasks/Callback queue
    | |Intpr⬇↳ Cmpl⬇ (JITcompiler)|   |  +--------+  +----------+  +-----+     | |		- setTimeout(), DOM APIs, fetch(), localStorage, console, location
    | |Execution⬇⬇ ↙↗GarbageColtr|   +--------------------------------------- + |
    | | +----------+ +----------+ |                                              |
    | | |  Memory  | |  CALL    | |       +---------------------------------+    |     	- Microtasks Queue is like callback queue, but has priority over callback queue!
    | | |   HEAP   | |  STACK   |↗------↘ |        Microtasks Queue         |    |     	    e.g. fetch("https://github.com/sprculguy/programming.git").then(response => response)  
    | | |          | |          |  Event  +---------------------------------+    |     	            // 1. (response => response) is callback function related to promise
    | | |       *  | |          |  loop   +---------------------------------+    |				 // 2. Mutation Observer - DOM Tree changes observer
    | | | *        | | __F2EC__ |↖------↙ |         Callback Queue          |    |    	- Callback queue is a data structure that contains all the callback/handler functions that are ready to be executed
    | | |    *  *  | | __F1EC__ | |       |  +-----+  +-----+  +----+       |    |     	   example; eventHandlerFunction - callback function from 'click' DOM event listener
    | | |  *   *   | | __GEC___ | |       |  |click|  |timer|  |data|  ...  |    |     	       as soon as 'click' event happens in the DOM, eventHandlerFunction() defined in the addEventListener gets added to callback queue.
    | | +----------+ +----------+ |       |  +-----+  +-----+  +----+       |    |     	       then as soon as the call stack is empty, the callback queued function will be passed to call stack by 'Event Loop' for execution.
    | +---------------------------+       +---------------------------------+    |
    |                                                                            |		- Automated sheduled JS engine defined garbage collection(central memory management tool) releases the unreferenced heap memory allocations
    +----------------------------------------------------------------------------+			(variables can be referenced by global execution context , EC of functions, active event listner or timers, closures)
																							
	Note - 
			Trust Issue: blocking main thread results in blocking callback queued functions execution



** JS Engine: A JavaScript engine is simply a computer program that receives JavaScript source code and compiles it to the binary instructions (machine code) that a CPU can understand.
                    JavaScript engines are typically developed by web browser vendors. Examples: V8 engine for Google chrome, SpiderMonkey for Firefox, and Chakra for Internet Explorer.

            Contains; 
                    1. call stack - responsible for code execution using "Execution Context", gets the stack of Execution Contexts
                    2. heap - unstructured memory pool to store the objects memory



** EXECUTION CONTEXT - 
            Browser can't understand high-level JS so the js code from web pages is sent to Browsers JS Engine that creates Execution context(environment) in call stack for execution
                during runtime, it's like a box where all the necessary information(local variables) for code execution is stored
            Execution Context consists of;
                    1. Variable Environment - variable environment of EC is always preserved for enclosed function that is why Closures are possible
                            - let, const, and var declarations
                            - Function
                            - argument object(arguments that were passed to the function that the current execution context belongs to)
							- references to objects
                    2. Scope chain - lexical 
                    3. 'this' keyword  
                            - method -> 'this' = <object that is calling the method>       
                            - function expression -> 'this' keyword refers to the global object(windows in browser). that is problematic, 
                                    so to avoid this 'use strict' should be used so that 'this' object for function expression will point to undefined
                                        'this' = undefined  // in 'use strict' mode 
                                    otherwise;
                                        'this' = <windows>  // without strict mode, (in the browser)
                            - arrow functions -> doesn't get argument object and 'this' keyword in their execution context rather they can use this functionality from their closest normal function parent
                                        'this' = <this of parent scope (lexical 'this')>
                            - eventHandlerFunction() -> 'this' = <DOM element that event is attached to>
                            - 'new', 'call', 'apply', 'bind' -> 'this' = _____



'use strict';   // literal expression used at most start of the script to execute that script in strict mode which provide highlighting and prevention of errors
debugger;       // keyword used to add breakpoint for the debugging



** Statement vs Expression:
        code that doesn't produce/return any value on successful execution is statement(s)
            e.g. const x = `this variable declaration is statement as it doesn't return any value`

        code produces/return a value is expression(s)
            e.g. `this is an expression`



** OPERATORS--(with precedence)
		Operators in the same box have the same precedence
		Operators in the same box group left to right
		comparisons, membership tests, and identity tests, all have the same precedence and have a left-to-right chaining

        |***	OPERATORS (with precedence)						        |	***		DESCRIPTION

        |(expressions...), [expressions...],						    |	Binding or parenthesized expression, list display,
        |{key: value...}                    							|	object display

        |x[index],                              					    |	Subscription,
        |x(arguments...), x.attribute								    |	fn call, attribute reference

        |x++, x--													    |	pre-increment, pre-decrement
        |++x, --x													    |	post-increment, post-decrement
        |x+=2, x*=5                                                     |   compound Assignment with augmented expression
        |**															    |	Exponentiation 
        |+x, -x, ~x													    |	Positive, negative, bitwise NOT
        |*, /, //, %												    |	Multiplication, division, floor division, remainder 
        |+, -														    |	Addition/concatenation and subtraction
        | &&													        |  	Logical AND // used on any data type and returns any data type
        |                                                                 |     // 3 &&'A'      returns 'A'       // returns last truthy value
        |                                                                 |     // 2 && 3 && 1  returns 1           
        |                                                                 |     // ''&& 0       returns 0         // returns first Falsey value(short circuiting)
        |                                                                 |     // 1 && '' && 2 returns ''          
        | ||  												            |	Logical OR  // used on any data type and returns any data type
        |                                                                 |     // 3||'A'    returns 3       // returns first truthy value(short circuiting)
        |                                                                 |     // ''||'A'   returns 'A'     
        |                                                                 |     // ''||0||1  returns 1
        |                                                                 |     // ''||0     returns 0       // returns last Falsey value
        | !															    |	Logical NOT
        |<, <=, >, >=, !=, ==				                            |	Comparisons (does type conversion)
        |===, !==                                                       |   strict equality operator;  doesn't allows type coercion.eg, 3=='3' is true but 3==='3' is false
        | ??														    |	Nullish Coalescing Operator, x1 ?? x2   // returns x2 if x1 is nullish(null or undefined) Nullish values are null and undefined (not "" or 0)
        |                                                                 |     // const guest = 0;         Nullish Coalescing operator is same as or(||) operator
        |                                                                 |     // noOfGuestPresent = guest || 10   // this gives 10 even if the number of guest is 0
        |                                                                 |     // noOfGuestPresent = guest ?? 10   // this solves above problem and gives value zero, not 10
        |?.                                                             |   Optional chaining operator;  // returns nullish values if doesn't find value to left else executes right-side expression(obj?.property or arr[0]?.property)   
        |                                                                 |     // obj.property1?.property11  // checks if property1 exists then executes expression otherwise returns nullish value(undefined)
        |                                                                 |     // obj.method?.() ?? 'method not exist'  // if method doesn't exists then it was returning undefined(nullish value), to avoid this we use nullish Coalescing operator
        |                                                                 |     // arr[0]?.property ?? 'object array is empty'   
        | ...                                                           |   Spread operator(seperate away - used RHS of '=')(for iterables(string, arrays, maps, sets) but NOT OBJECTS) eg. ...arr
        |                                                                 |     // x = [1,2,3]  then, ...x = 1, 2, 3 and [1, ...x] = [1, 2, 3]
        |                                                                 |     // s = "Ank"    then, ...s = 'A', 'n', 'k' and [...s] = ['A', 'n', 'k']
        |                                                               |   Rest Operator(groups together - used LHS of '=') eg. function(...args){}    // args = [parameters separated by commas]
        |                                                                 |     // x = [1,2,3,4]  then, const [a, ,...remaining] = x; a=1, remaining=[3,4] 
        |                                                                 |     // obj = {'mon':1,'tue':2,'wed':3}      then, const {mon, ...otherDays} = obj; mon=1, otherDays = {'tue':2,'wed':3}
        | ` Hi my name is ${name},                                      |   Template Literal - Multiline + Formatted string
        |   I am ${age} years old. `

        |\                                                              | Escape character for escape sequences; \',\",\\,\n,\t,\b
        |//														        |- Comment
        |/* 														    |- Multiline Comment 				
        |_block_														|
        |*/															    |    



** DATA SOURCES -
        1. Source Code  - written in source code (e.g. status messages)
        2. UI           - user input from DOM (e.g. tasks from TODO, etc.)
        3. Web API      - data fetched from web API (e.g. whether data, data about movies, currency conversion rates, etc.) // generally in JSON

        JS has total of 6 built-in data structures,
            Array - ordered data, easy manipulation/fetching
            Set - unique items(removes duplicates), high-performance(as searching/deleting is faster than arrays)
            Object - keys must be strings, easy to write and access, used when want to include methods(and has 'this') or working with JSON
            Map - better performance(than objects), easy to iterate & compute size, keys can have any data type value
            Weak-maps
            Weak-sets



** DATA TYPES--(Dynamically typed languages - variable types are decided in the runtime)
            Primitive - gives duplicate when copied | stored in stack | no methods
                number  (NaN is also of number type) - all numbers are represented as floating point numbers internally in 64 bit binary format(i.e. 24 === 24.0 => true)
                string
                boolean
                null
                undefined(undefined is both value and type of value)
                symbol(values that are unique and unchanged)
                BigInt(larger values than number type can hold) let big = 7445676536389867646n or BigInt(2)

            Reference - [] () {} - gives reference when copied | stored in heap | have methods
                arrays, functions, collections, dates, and all other types of objects
                    - To copy the reference variables, use spread(...) operator - spread operator gives all the elements without creating new variable
                        arr = [1,2,3,4]
                        arrCopy = [0, ...arr, 5]                       // ...arr = 1, 2, 3, 4      ||      arrCopy = [0, 1, 2, 3, 4, 5]
                        obj = {1:"One",2:"Two",3:"Three",4:"Four"}
                        objCopy = {...obj} || objCopy = Object.assign({}, obj)    // gives shallow copy, as only first level properties are copied, to also copy a nested object we can use structuredClone() or 'lodash' module using npm
                                                                // if any property is object, that property will be pointing to the same heap memory location for both the obj and objCopy. i.e. obj.nestedObj.flag == objCopy.nestedObj.flag
                        objCopy = structuredClone(obj)    // gives deep copy/clone, as all level properties are copied, i.e. also copy a nested objects.
                                                                // if any property is object, that property will be copied in objCopy. i.e. obj.nestedObj & objCopy.nestedObj will be pointing to different heap memory location
            Note - JavaScript converts primitive strings to string objects, so that it is possible to use string object methods like, str.length

        Variable Declaration-   
                var name;                     // var has function scope             // can be redeclared and reinitialized multiple times
                let name;                   |                                       // can't be redeclared
                const name = "Ankit";       | // let and const has block scope      // must be initialized with declaration only, redeclaration is not allowed
                typeof x;                     // Gives the type of the x variable/value
                        for example.
                                function Numbers(){
                                    for(var i = 1; i < 11; i++){
                                        console.log(i)
                                    }
                                    console.log(i)           // gives i = 11 as 'var' variable 'i' is scoped in parent function(Numbers()) block. 
                                }                                 // ie, can be used anywhere inside Numbers() function.

                                function Numbers(){
                                    for(let i = 1; i < 11; i++){
                                        console.log(i)
                                    }
                                    console.log(i)          // gives reference errors, as let variable 'i' is only scoped inside 'for' block
                                }

        Number - (NaN is also of number type) 
            - all numbers are represented as floating point numbers internally in 64 bit binary format(i.e. 24 === 24.0 => true)
            - out of 64 bit, only 53 bits are used for numbers rest bits are used for position of decimal point and sign(-/+)
            - Number.MAX_SAFE_NUMBER    => max number value that is stored in js number variable
            - Numeric Seperator (1_23_456 => 123456) should be like 1_1 and not 1._ _1

                Number Methods - 
                    Number.isNaN(x)         // to check if x is NaN value
                    Number.isInteger(x)     // to check if x is integer value
                    Number.isFinite(x)      // to check if x is number/floating value(and not infinite i.e. 1/0)

                    Math.sqrt(4) === 4**(1/2) === 8**(1/3)      => 2 === 2 === 2
                    Math.max(2,56,"87",12,34,9)                 => 87     // Type Coercion (internally convert string to number)
                    Math.min("2",56,"87",12,34,9)               => 2      // Type Coercion (internally convert string to number)

                    Math.PI                                     => 3.14
                    Math.random()                               => x      // 0 < x < 1
                        - Math.trunc(Math.random()*6)           => 0 to 5
                        - Math.trunc(Math.random()*(6-2)) + 2   => 2 to 5

                    Math.trunc(3.14) === Math.trunc(3.94)       => 3 === 3
                    Math.trunc(-3.14) === Math.trunc(-3.94)     => -3 === -3
                    Math.floor(3.14) === Math.floor(3.94)       => 3 === 3
                    Math.floor(-3.14) === Math.floor(-3.94)     => -4 === -4
                    Math.ceil(3.14) === Math.ceil(3.94)         => 4 === 4
                    Math.round(3.14) !== Math.round(3.94)       => 3 !== 4     

                    `2`.padStart(3, 0)                          => 002
                    (3.14).toFixed(0) !== (3.94).toFixed(0)     => 3 !== 4  // returns string
                    (3.14).toFixed(3)                           => 3.140    // returns string
                    +(3.145).toFixed(2)                          => 3.15    // returns string so to convert into number we are using +

        String -
                const s = "string" / 'string'
                const s = `this is ${expression}
                            string`

                String Methods - strings are immutable so all methods return new strings
                    s.length;
                    s[s.length - 1]         -> last character
                    s.at(-1)                -> last character
                    s.indexOf("g")          -> 5    for s="string"      // gives first occurred characters index
                    s.lastIndexOf("ng")                             // gives last occurrence character index
                    s.includes("string")    -> true/false
                    s.startsWith("s")       -> true/false
                    s.endsWith("g")         -> true/false
                    s.slice(1, -1)                                  // return the string from index 1st till second last character(as 2nd index is exclusive)
                    arr = s.split(" ")      -> array of 's' words spitted by " "
                    new_s = arr.join(" ")   -> all elements from arr joined by " " to create a string         
                    s.toLowerCase()
                    s.toUpperCase()
                    s.trim()                                        // trims the white spaces both from start and end
                    s.trimStart() s.trimEnd()
                    s.replace(" ", "space")                         // replaces first occurrence of " " to "space" and returns string
                    s.replaceAll(" ", "space")                      // replaces all occurrences of " " to "space" and returns string

                    Regular Expression - 
                        s.replace(/" "/g, "space")                     // regular Expression with (/''/g) Global Flag so All the Occurrences Are Targeted           

        Object Literal(mannual object creation. i.e. not programmatically using class) -
                var a = {}   or   var a = new Object(a)

                const backpack = {                                  // can change the properties of object but can't reassign all properties of backpack container/variable
                                name: "Everyday Backpack",                                      for ex. > const x = {'1':'One', '2':'two'}
                                volume: 30,                                                             > x = {'1':'One', '2':'two'} // will give error
                                color: ["grey", "blue"],
                                "pocket Num": 15,
                                strapLength: {
                                    left: 26,
                                    right: 26,
                                },
                                lidOpen: false,
                                toggleLid: function (lidStatus) {                           // toggleLid is the method of backpack object
                                    this.lidOpen = lidStatus;                               // 'this' keyword refers to caller object
                                    updateBackpack(`Lid status changed.`);
                                },
                                newStrapLength(lengthLeft, lengthRight) {                   // same as; newStrapLength : fuction(lengthLeft, lengthRight) {}
                                    this.strapLength.left = lengthLeft;
                                    this.strapLength.right = lengthRight;
                                    updateBackpack(`Strap lengths updated.`);
                                    console.log(this);                                         // logs whole object from which the 
                                },
                            };

                backpack.name
                backpack["pocket Num"]                      // usable if object property has space in its name, same as 'backpack.pocket Num'
                backpack.color[0]

                backpack.hasOwnProperty("lidOpen")          // returns true
                delete backpack.name
                backpack?.size                              // Optional chaining - doesn't gives error even if size is not property of backpack

                Object Method/Properties - 
                    var obj = { 1:"One", 2:"Two" }
                    delete obj.2;           // obj becomes { 1:"One" }

                    Object.keys(obj)            // gives all keys array
                    Object.values(obj)          // gives all values array
                    Object.entries(obj)         // gives all keys and values arrays     // this methods converts objects to maps 

					const objArr = [{name: "ankit", type: "saving"}, {name: "Nikita", type: "saving"}, {name: "Bharti", type: "current"}]
					Object.groupBy(objArr, (current, i) => i)				-> {'0': {...}, '1': {...}, '2': {...}}
					Object.groupBy(objArr, (current, i) => current.type)	-> {saving: [{...},{...}], current: [{name: 'Bharti', type: 'current'}]}
					Object.groupBy(objArr, ({type}, i) => type)				-> {saving: [{...},{...}], current: [{name: 'Bharti', type: 'current'}]}	// de-structuring

        Arrays (objects that treated differently) -
                var a = [12,13];            a[0] = 12       a is converted to object; i.e.. a = {0:12, 1:13}
                                                            so we can assign negative index manually, a[-1] = 11
                const a = new Array(1,2,3,4)        // using constructor function('new')
                const a = new Array(5)                  // a=[ empty*5 ] & a.length = 5  i.e. creates empty array with size 5
                a.fill(0, 2,3)                              // a=[ empty*2, 0, empty*2 ]  mutates 'a'
                const a = Array.from({length:5}, (cur, i) => i+1)               // a=[1,2,3,4,5]
                const a = Array.from(nodeList, element => Number(element.textContent))    
                const a1 = [1,2,3,4]

                a1[0]               |// gives 1(first element)
                const [a] = a1      |   a = a1[0]
                a1.at(0)            |

                a1[0] = 5    		// allowed as changing element is possible for non-primitive variables	a1 = [5,2,3,4] // array mutation
                a1 = [6,7,8,9]    	// not allowed as a1 is const, we are not allowed to change the memory location present in stack variable a1

				x = a.with(index, value)		// return new array with given index modified by given value without array mutation
				a2 = a1.with(0, 1)			->	a2 = [1,2,3,4]  & 	a1 = [5,2,3,4]

                const a3 = [a1, `Ankit`, lastName, 2024-2001]

                a3.indexOf(`Ankit`)    	// returns 1
                a3.indexOf(`Ankita`)    // returns -1

                a3.includes(`Ankit`)    // returns true    uses strict equality (===)
                a3.includes(`Ankit`)    // returns false

                Array Methods - 
                    a.length                                                 	-> number of elements in array

                    a.at(-1)                                                 	-> last element
                    a.indexOf(value)                                         	-> index / -1
                    a.findIndex(function(current, i, a){return true/false})  	-> returns first element index for which callback function return true of array elements
                    a.findLastIndex(function(current, i, a){return true/false}) -> returns last element index for which callback function return true of array elements
                    a.find(function(current, i, a){return true/false})       	-> returns first element for which callback function return true of array elements
                    a.findLast(function(current, i, a){return true/false})   	-> returns last element for which callback function return true of array elements

                    a.includes(12)                                           	-> true/false      // checks for equality
                    a.some(function(current, i, a){return true/false})       	-> true/false      // checks for availability
                    a.every(function(current, i, a){return true/false})      	-> true/false      // true if callback function returns true for every/all values of array 

                    a.concat(a1)                                             	-> [...a, ...a1]	// returns new array, unlike push 
                    a.join("")                                               	-> string with all 'a' elements

                    a.flat() / a.flat(1)    // if a=[[1,2],3,[4,[5,6]]]      	-> [1,2,3,4,[5,6]]     // flat one level nested array
                    a.flat(2)               // if a=[[1,2],3,[4,[5,6]]]      	-> [1,2,3,4,5,6]       // flat 2 levels nested array
                    a.flatMap((x, i, a1) => x.array)           // map + flat	

                    a.reverse()                             reverse elements of 'a' as well as return new reverse elements array too
                    a.toReverse()                           return new reverse elements array without original array mutation
                    a.sort()   // sort array elements according to strings   -> sorted array in ascending order with original array mutation
                    a.sort((a,b)=> a-b)     ascending   // if callback function returns negative value, a and b gets swapped in array
                    a.sort((a,b)=> b-a)     descending  
                    a.toSorted()   // sort array elements according to strings   -> sorted array in ascending order without original array mutation

                    a.push(14)          add at the end, modifies existing array
                    x = a.pop()         remove form the end and return last value
                    a.unshift(11)       add at the start
                    x = a.shift()       remove from the start and return first value

                    x = a.slice(start)  
                    x = a.slice(3)          returns new array from 3rd index element, without changing 'a'
                    x = a.slice(-2)         returns new array from 2nd last index element of 'a', without changing 'a'
                    x = a.slice(start,end)  excluding 'end' index
                    x = a.slice(1, 3)       returns new array with 1st index till 2nd index, without changing 'a'

                    x = a.splice(index)    
                    x = a.splice(3)         returns new array from 3rd index element and also remove them from 'a'
                    x = a.splice(index, number)
                    x = a.splice(1, 2)      remove 2 values from 1st index of 'a' and return remaining elements in x
					x = a.toSplice(3)		returns new array from 3rd index element, without changing 'a'

                    sqInt = a1.filter((num, i, a1) => Number.isInteger(num) && num > 0).map((x, i, a1) => x*x);   // map method creates new and forEach doesn't
                                            // filter the value based on true/false returned by callback function(filter function argument)
                    sum = a1.reduce((accumulator, current, i, a1) => accumulator + current, 0)          // sum = 10 / 0(accumulator initial value)   // a1 = [1,2,3,4]

                    a.entries()       -> map with index and values arrays       // this methods converts array object to maps
                    a.forEach(function(item, index, a){})       // changes done in temporary copy of arr  |  break/continue can't be used

					Object.groupBy([2,-2], (current, i) => current>0 ? 'positive' : 'negative')	-> {positive: [2], negative: [-2, -34]}
					Object.groupBy([2,-2, 1], (current, i) => i)								-> {'0': [2], '1': [-2], '2': [-34]}

        Sets (iterable) - collection of unique values // no way to retrieve value using index/method but can be iterated
                const set = new Set("Any iterable ")                     iterables are - string, arrays, maps, sets
                        // set = {'A','n','y',' ','i','t','e','r','a','b','l','e'}

                Set Methods -
                    set.size        gives length of set values
                    set.has('A') 					-> true/false
                    set.add('A')					-> same set reference(memory location)
                    set.delete('A')					-> true/false
					set.clear()		

					set1.intersection(set2)			-> new set with common elements present in both set1 & set2
					set1.union(set2)				-> new set with all elements present in both set1 & set2 without duplication
					set1.difference(set2)			-> new set with all unique elements in set1 which are not present in set2
					set2.difference(set1)			-> new set with all unique elements in set2 which are not present in set1
					set1.symmetricDifference(set2)	-> new set with all elements present in both set1 & set2 except intersecting elements

					set1.isDisjointFrom(set2)		-> true/false  	| checks if both sets have no common element
					set1.isSubsetOf(set2)			-> true/false	| checks if all elements in set1 are present in set2
                    set1.isSupersetOf(set2)			-> true/false	| checks if all elements in set2 are present in set1

					for(const item of set) console.log(item)
                    set.forEach(function(item, item, set){})       // changes done in temporary copy of set  |  break/continue can't be used

        Maps - key-value pairs where the keys can be any datatype(for objects, must be strings) and ordered by intersection
                const fruits = new Map([                            fruits = {                                                            }
                                            ["apples", 500],                    "apples" => 500,
                                            [[1,2,3], 300],                     [1,2,3] => 300,
                                            [{1:'a'}, 200]                      {1:'a'} => 200
                                        ]);  {                               }
                Map Methods -
                    fruits.set(arr, "Test"); => whole map    //adding or changing existing map value
                    fruits.get(arr)
                    fruits.has("apples")  => true/false
                    fruits.delete("apples")
                    [...fruits]                     // convert map to array
                    [...fruits.keys()]              // convert map to map keys array
                    [...fruits.values()]            // convert map to map values array
                    map.forEach(function(value, key, map){})       // changes done in temporary copy of map  |  break/continue can't be used

        Truthy, Falsey and Nullish values
                Falsey values - 0, false, undefined, null, NaN(invalid number/not a number), ``, document.all
                Truthy values - other than Falsey values
                Nullish values - undefined, null     // used with Nullish Operator(??). i.e. (x ?? y) -> returns y if x is nullish otherwise returns x



** Date/Time/Time Zone
    const nowUTC = new Date()                                                   => 2024-01-01T00:00:00.000Z  (Object)
    const now = new Date(new Date().getTime() + 5.5*60*60*1000).toJSON()        => 2024-01-01T00:05:30.000Z  (string)
    Number(now) == +now                 => 1725277002705    (mili seconds, reference to 1970-01-01T00:00:00.000Z)

    const daysSubstraction = (new Date(2024, 8, 23) - new Date(2024, 7, 23)) / (1000*60*60*24)

    const day = now.getDate()          
    const month = now.getMonth() + 1      // because, jan == 0 && dec == 11
    const year = now.getFullYear()
    const hour = now.getHours()
    const min = now.getMinutes()



** Timers - 
    const timer = setTimeout(function, 5*1000, arg1, arg2)          // calls function with arguments after at least(trust issue) 5 seconds/5000 milliseconds, as 1 sec = 1000 milli
    clearTimeout(timer)                                             // abort the callback of timer

    const intervalTimer = setInterval(function, 5*1000, arg1, arg2) // calls function with arguments after every 5 seconds/5000 milliseconds again and again
    clearInterval(timer)



** Parsing - Type conversion (explicit with functions)
        parseInt(" 34$ ")     Number("34")                              returns 34      // parseInt argument should be starting with number
        parseInt("f")       Number("f")                                 returns NaN 
        parseFloat(" 34rem ")                                           returns 34
        String(12)                                                      returns "12"
        12.toString()                                                   returns "12"
        5.toString(2)                                                   returns "101"
        Boolean("0")                                                    returns true
        Boolean(0)                                                      returns false



** Type Coercion - Js implicit type conversion
        Unary Operator 
            let y = "5"         string
            let x = +y          number
            let z = "A"         string
            let x = +z          invalid number(NaN)

        Binary Operator
            all expression rather than +(concatenation) Operator converts strings into number
                e.g. x = 5 + "7"     "57"
                    x = 5 - "7"     -2
                    x = 5 * "7"     35



** De-structuring Operator - short form to assign object property values to the variable
        [y, x] = [x, y]             // swapping values of two variable

        const arr = [1, 2, [3, 4]];
        const [x, , y=0, z=0] = arr;        // x=1, y=[3, 4], z=0       // with default value
        const [x, , [y, z]]                 // x=1, y=3, z=4

        obj = { 
            property1 : {
                property11 : value11,
                property22 : value22
            },
            property2 : value2
        }
        const { property2 } = obj;                                                      // property2 = value2
        const { property2 : p2 } = obj;                                                 // p2 = value2
        ({ property2 } = obj)                                                           // property2 = value2
        const { property2 : x=[], property1 : {property11 : y, property22} } = obj;     // x = value2, y = value11, property22 = value22
        const { property3 : z=[] }                                                      // z = []           // with default value



** Memory Management
	- Automatic Memory management through memory life cycle
		1. Memory Allocation [let temp = 10]
		2. Memory Usage [temp += temp;]
		3. Memory Relese [auto garbage collection]

	- memory allocated to variables is relesed; 
		1. Call stack	- variable environment is simply deleted when exicution context pops off the call stack
		2. Heap 		- Automated sheduled JS engine defined garbage collection(central memory management tool) releases the unreferenced heap memory allocations
							(variables can be referenced by global execution context , EC of functions, active event listner or timers, closures)

	[note - Variables declared in the global execution context (the top-level scope of your JS code) will generally not be garbage collected as long as the page or script is running]
	[note - Variables in closures will not be garbage collected as long as the closure itself is alive]
	[note - Variables in not deleted event listener and timers will not be garbage collected as long as the event listener or timer itself is alive]



** HOISTING - variables and functions are hoisted i.e. only their declaration (var a;) is added to the execution context of script in memory
        because of hoisting,
            - 'var' and functions are hoisted in global space and are assigned to "undefined"
            - 'let' and 'const' are accessible only after initialization as they are hoisted in separate memory(that is reserved for the block) space,
                    so they will give "ReferenceError" if accessed before initialization, before initialization they are in TDZ(Temporal Dead Zone)

        Exceptions
            Classes are not hoisted
            NullPointerException (NPE) is an error that occurs when a program tries to access or manipulate data
                through a reference that points to a non-existent object or has a null value.
            The equivalent error is a TypeError when accessing properties or methods of null or undefined objects.

                                    |    Hoisted     |             Initial value               |     Scope     |
        ----------------------------|----------------|-----------------------------------------|---------------|
        Function Declaration        |      Yes       |            Actual Function              |     Block     |                                  
        var variable                |      Yes       |               undefined                 |    Function   |                          
        let, const variable         |       No       |   <uninitialized>, Temporal Dead Zone   |     Block     |                                  
        function expression/arrows  |cant use before initialization as variable is hoisted with value undefined|



** O/P-I/P
    console.log(`outputs to console`)			// for basic output and to display simple values.
    console.dir(r)								// to inspect the structure of objects or DOM elements in more detail.
    console.warn()              
    console.error()                 
    console.table(object)                       // gives key-value rows in table on console

	alert(`browser provided notification window`);
    prompt(`// gives pop-up windows with input field and returns input string`);



** Conditionals - 

        IF
            if() {}
            else if() {}
            else{}

        SWITCH
            switch(char) {           
                case 'a':           
                    __statement__       // multiple statements can be used without {}.
                    __statement__
                    break
                case 'b':               // if the value is 'b' or 'c' code of c will be executed.
                    __statement__
                case 'c':
                    __statement__
                    break
                default:
                    console.log(`Not a valid character!`)
            }



**Ternary Operation - 

        condition ? statement-if-true : statement-in-false

        condition1 ? statement1-if-true: condition2 ? statement2-if-true: statement-if-false



** Loops -
        FOR
            for(var i;i<=10;i++) {}

        FOR OF 
            for(const i of arr) console.log(i);
            for(const [index, item] of arr.entries()) console.log(`${index + 1} : ${item}`);         // object is first converted in map using entries method 

        FOR IN
            for(const i in arr) console.log(arr[i]);                        // array
            for(const key in obj){ console.log(`${key} : ${obj[key]}); }      // object

        FOR EACH Method
            - changes done in temporary copy 
            - break/continue can't be used

            arr.forEach(function(item, index, a){console.log(`${item}, ${index}, {$a}`)})                                   // array
            map.forEach(function(value, key, map){console.log(`${key}, ${value}, {$map}`)})                                 // map
            set.forEach(function(item, _, set){console.log(`${item}, {$set}`)})                                             // set
            new Map(Object.entries(obj)).forEach(function(value, key, objMap){console.log(`${key} : ${value} ${objMap}`)})  // object
            nodelist.forEach(function(item, index, a){console.log(`${item}, ${index}, {$a}`)})                              // nodelist

        WHILE
            while() {}

        DO-WHILE 
		    - will be executed at least once(even if condition is false)
            do{
                console.log(a)
                a++
            }while(a<5)



** Functions - Block Scoped in 'use strict' mode
			- Function always has access to the variable environment of the execution context in which the function was created
            - Function are just another type of object, function has properties and methods i.e. functionName.name
            - 'call', 'apply' & 'bind' method can be called on function, i.e. functionName.bind()

        Function statement/declaration - way of creating a function
                function funcName(parameters, a=10, b=a+1) {}           // default parameter

                funcName(arguments, undefined, 100);  // a=1, b=100     // can be called before declaration of function because of hoisting

        Rest operator(...) - for variable number of arguments in form of array
                function funcName(...args) {            // if, x = [1,2,3]   then, ...x = 1, 2, 3   and [ , ...x] = [2, 3]
                    return args.reduce((a,b) => a+b, 0)
                }

                funcName(arguments);

        Passing Object as arguments
                function funcName(property1, property2) {}          // getting object properties as parameter
                            // if we change the properties in function, obj also changes as reference is passed which points to same object
                obj = {property1 : value1, property2 : value2}
                funcName(obj)

        Function Expression - Function acts like a value | can't be called before declaration of function
                var x = function() {}

                x();    
                    // function call, gives error when called before creation as var x is hoisted and assigned with Undefined

        Named Function Expression
                var x = function y() {}

                x();    
                y();                // gives reference error

        Arrow Function - function behaving like a variable, short form for the function definition | 
                            doesn't get argument object and 'this' keyword in their execution context, rather they can use this functionality 
                                                        from their closest normal function parents 'this' keyword
                const gerName = (arg1, arg2) => { }           // const gerName = function() {}
                const x = arg => { }

        Anonymous Function - function without name. can have multiple arguments, but only one expression

                function() {}           // gives syntax error to fix the error
                (function() {})         // function converted into expression
                (function() {})()       // when defined this function expression is executed only once

                var greet = function (parameters){            //using function expression; same as greet = (function(p){})
		            console.log(`Welcome to ${parameters}`);        // parameters is function scoped variable
	            }

	            let greet = () => console.log("Welcome to GeeksforGeeks!");         // using arrow function

                greet();            // as we have only one expression in function so we can ignore the {}
                                    // function call, gives error when called before creation as var greet is hoisted and assigned with Undefined

        Self-Executing Function/Immediately Invoked Function(IIFE) - done by converting function into expression then invoking() it
            - Only executed once
            - code line previous to "Self-Executing Function" should be terminated by semicolon(;)

            (function (parameters){                                                 // converting function into expression
                console.log(`Welcome to ${platform}`);
            })();

            (() => {                                                                // using arrow function
                console.log("GeeksforGeeks"); 
            })();

        First class function/citizen 
                - ability to use function as arguments, parameter or returning values for the function

        Higher Order Function - function that receives another function(callback function) as argument that returns a new function(returned function)
                              - only possible because of first-class functions
                e.g.              
                    function x(z){                // taking parameter as a function; x is higher order function
                        var a = 7;
                        z();
                        return function {        // returning anonymous function from function x; this anonymous function is returned function
                            console.log(a);
                        }
                    }
                    function y(){ }
                    var r = x(function z(){ });     |
                    var s = x(y)                    |passing function as argument
                    var t = addEventListener("click", function(e){})        // t is Higher Order function and argument function is CallBack function

                map, filter, reduce, addEventListener, parent function in closures 

        Callback function
            setTimeout(function(){}, 2000)      // calls callback function after 2000 miliseconds(2 sec)
                        eg. function x() {                  // this function will print 1 after 1 second, 2 after 2 seconds and so on till 5
                                for(let i = 1; i <= 5; i++) {
                                    setTimeout( function () {
                                                                console.log(i);
                                                            }, i*1000);
                                }
                            }
                            x();

        Function Methods - 'call', 'apply' & 'bind'
            'call' - to manipulate/modify 'this' value for that function call
                const funcName = obj.fn;         // gives copy of fn() inside of obj to external function(funcName)
                funcName(args);                  // by default function call assigns 'this' === undefined (in "use strict")
                funcName.call(objName, args)     // for this function call with 'this' === objName

            'apply' - to manipulate/modify 'this' value for that function call
                funcName.apply(objName, [args])         // for this function call with 'this' === objName

            'bind' - returns new function with 'this' value for function, and set it as arguments
                newFunc = funcName.bind(objName, value)     // newFunc.this === objName
                newFunc = funcName.bind(null, value)     // first argument already set(partial application) to value for returned function
                newFunc(arg1)                               // every function call assigns 'this' === objName and arg1 === value   

                document.querySelector('.btn').addEventListener('click', fn)                // by default, 'this' === <button class="btn"></button>
                document.querySelector('.btn').addEventListener('click', fn.bind(obj))      // for returned fun, 'this' === obj



** CLOSURES -   Variable Environment(including parameters) of EC is preserved for enclosed(child) function, even after that EC is gone or enclosing(parent) function has returned
                Closure variables take priority against global variables
                Not accessible outside(Encapsulation)

            function x(){       
                var a = 7;
                function y(){			// Function always has access to the variable environment of the execution context in which the function was created
                    console.log(a);
                }
                y();		
                return y;
            }             // Function y() along with its lexical scope(variables/parameters - Variable Environment) x() bundles together forms a closure
            var r = x();      // because to closure(x), even after x() vanished(returned), closure still remembers it for y()
            r();                / will give output as "> 7" 
            console.dir(r)

        Uses of Closures
            - Module design pattern
            - currying
            - Functions like once(function that only executes one time)
            - memorize
            - maintain state in async world
            - setTimeouts
            - Iterators

        Advantages of Closures
            - Function currying
            - Data Hiding
            - Encapsulation
            - Module Partition

        Disadvantages of Closures
            - Overconsumption of Memory as closure variables are not garbage collected
            - Memory Leak possibility(variables which are not required/must be deleted are still accessible and hence not garbage collected)



** TO access/manipulate DOM - ability to change HTML text, attributes or CSS styles as well as listen and respond to events
    - DOM is very complex API that contain lots of methods(.querySelector(), addEventListener()) and properties(.innerHTML, .textContent) to interact with DOM tree

    +--------------------------------------------------------------------------------------------------------------------+    Example of DOM tree for <a>
    | DOM API                                       +------+    (js object with properties; .textContent,                |          document        |<html>
    |                                               | Node | <-    .childNodes, .parentNode, .cloneNode() )              |              |           |    <body>
    |                    +--------------+-----------+------+----------+-----------------+                                |            <html>        |        <p>
    |                    ⬇              ⬇             ⬇               ⬇                 ⬇                                |              |           |            <a>click</a>
    |(inherits all   +-------+       +----+       +-------+       +--------+      +------------+                         |            <body>        |        </p>
    |properties of → |Element|       |Text|       |Comment|       |Document|      |Event Target| ← (.addEventListener()  |              |           |    </body>
    |  parent)       +-------+       +----+       +-------+       +--------+      +------------+  .removeEventListener())|             <p>          |</html>
    | eg. .innerHTML <p>,<Button>,   Paragraph   <!--comment-->                         ⬆                                |              |   
    |                 <a>, <div>                                                     +------+                            |             <a>
    |                                                                                |Window|   (Global Object, lots of  |
    |                                                                                +------+    methods and properties) |                                                                                                                       
    +--------------------------------------------------------------------------------------------------------------------+
        - 'document' is (1st most/root)node of DOM tree given by web api(browser implemented libraries written in js) that accessed using js

    DOM Events Lifecycle - from the moment webpage first accessed until the user leaves it  
        1. 'DOMContentLoaded' event - fired on document as soon as HTML+JS fetched and converted into DOM tree finished(excluding img and other external content)
            document.addEventListener('DOMContentLoaded', e => 'HTML parsed and DOM tree built!')

        2. 'load' event - fired on window after all the elements(including img, css and other external content) on webpage are loaded completely
            document.addEventListener('load', e => 'Webpage fully loaded!')

        3. 'beforeunload' event- fired on window just before user is leaving webpage
            document.addEventListener('beforeunload', function(e){
                e.preventDefault();
                e.returnValue = ''          // previously we can give custom messages for leaving confirmation(now we have generic message)
            })

    - Selecting and Manipulating web content -

        1. document.getElementById('idName')                   // access the matching first item
        2. document.getElementsByClassName('className')        // returns HTMLColletion, also called as LiveCollection
        3. document.getElementsByTagName('p')                  // returns HTMLColletion, as html dom changes this collection items changes

        4. document.querySelector('cssSelector')       // console.log(document.querySelector(".my-name").textContent);  // only selects first matched element
        5. document.querySelectorAll('cssSelector')    // returns nodelist, doesn't have methods like map()/reduce(). array methods on can be used. Selects all child and deeper elements from the 'document'
                                                            we can convert nodelist(any array like structure) to arrays using Array.from() or [...document.querySelectorAll('cssSelector')]
                eg. console.log(document.querySelector(".my-name").textContent);
                    document.querySelector(".my-name").textContent = `This is text from any tag except input`;

                    console.log(document.querySelector(".my-name").value);      // for input element
                    document.querySelector(".my-name").value


    - Adding/Removing HTML elements
        document.querySelector('p').innerHTML = '';             // removing the inner html of selected <p>
        html = `<p> My name is ${name} </p>`
        document.querySelector('p').insertAdjacentHTML('afterBegin', html)            
                                                        <!-- 'beforebegin' -->
                                                            <p>
                                                                <!-- 'afterbegin' -->
                                                                foo
                                                                <!-- 'beforeend' -->
                                                            </p>
                                                        <!-- 'afterend' -->

        document.querySelector('.header').prepend(document.createElement('div').innerHTML('here is buttn <button>Button</button>'))
                                                        <!-- '.before()' -->
                                                            <p class='header'>
                                                                <!-- '.prepend()' -->
                                                                foo
                                                                <!-- '.append()' -->
                                                            </p>
                                                        <!-- '.after()' -->


    - Traversing DOM elements
        - child
            const section = document.querySelector('.section')  // gives first child element node of section no mater how deep-child its on DOM tree
            section.querySelectorAll('.imp')                    // gives nodelist of all matched('.imp') child and deeper child nodes of the section
            section.childNodes                                  // gives nodelist of all direct child nodes(span, text, comment, br, etc.) of the section 
            section.children                                    // gives live HTMLColletion of only html element nodes(span, br) which are direct child of the section

        - parent
            section.parentNode                                  // gives direct parent node of the section
            section.parentElement                               // gives direct parent element node of the section
            section.closest('.header')                          // gives closest parent element node of section no matter how far-up parent it's on DOM tree
            section.closest('.section')                         // gives section itself as, section = document.querySelector('.section')

        - sibling(only access direct siblings - only consecutive prev and next node)
            section.previousSibling                             // gives direct sibling node that is previous of section, otherwise null
            section.previousElementSibling                      // gives direct sibling element node that is previous of section, otherwise null
            section.nextSibling                                 // gives direct sibling node that is next of section, otherwise null
            section.nextElementSibling                          // gives direct sibling element node that is next of section, otherwise null


    - Changing CSS(applies inline styles)
        document.querySelector('.btnCheck').style.width = '20rem';        // property value should be string including unit
        document.querySelector('body').style.backgroundColor = 'red';     // in css we use background-color but in js we use camelCase 

        - to get defined/browser computed styles from webpage
            getComputedStyle(document.querySelector('body'))    => returns object which contains all the styles(defined in style.css / computed by browser)

        - to modify CSS Custom properties(variables)
            document.documentElement.style.setProperty('--color-primary', '#34e572')
                        :root{                  // css variables defined on root, accessible throughout all document
                            --color-primary: #4e5678;
                            --color-secondary: #34e572;
                        }


    - Manpulating classes of HTML element attributes
        - standard attributes (must have in HTML defined properties)
            document.querySelector('.nav_logo').className   => nav_logo                             | // js will create standard 
            document.querySelector('.nav_logo').src         => http://127.0.0.1:8080/img/logo.png   |  attributes as properties of
            document.querySelector('.nav_logo').alt         => Logo For Navbar                      |  object obj.src, obj.alt, etc.
            document.querySelector('.nav_logo').getAttribute('src')             => img/logo.png
            document.querySelector('.nav_logo').getAttribute('myAttribute')     => my custom defined value for attribute

        - non-standard attributes (custom/user-defined attributes)
            document.querySelector('.nav_logo').alt = 'Logo For Navbar'                     
            document.querySelector('.nav_logo').setAttribute('myAttribute', 'my custom defined value for attribute')  

        - data attributes (special attributes stored in dataset object)
            document.querySelector('.nav_logo').dataset.versionNumber   => 3.0        // <img data-version-number="3.0"/>

        - class
            document.querySelector('.nav_logo').className = 'className'    
                // don't use above as it overwrites all present classes and set to only one className
            document.querySelector('p').classList.add('className1', 'className2', 'className3');  
            document.querySelector('p').classList.remove('className1', 'className2', 'className3');  
            document.querySelector('p').classList.replace('className1', 'className2');  
            document.querySelector('p').classList.toggle('className1', i < 10);  
            document.querySelector('p').classList.contains('className1');               => true/false

            let p = document.querySelectorAll('p')              // gives the array of all p elements
            for(let i=0;i < p.length; i++){
                p[i].classList.add('className');
                p[i].addEventListener('click);
            }


    - Manpulating Viewport/browser window
        document.documentElement.clientHeight           // current height of viewport(brouwser window) in pixels
        document.documentElement.clientWidth            // current width of viewport(brouwser window) in pixels
        x = window.pageXOffset                          // current horizontal scroll location in pixels
        y = window.pageYOffset                          // current vertical scroll location in pixels

        s1 = document.querySelector('.section1').getBoundingClientRect()               // returns dom rectangle object(position, width, height,..,etc.) 
        window.scrollTo({left: s1.left + x, top: s1.top + y, behavior: "smooth"})      // left and top will be relative to current viewport, in pixels
        document.querySelector('.section1').scrollIntoView({behavior:"smooth"})      


    - Handling Events (Event is a signal that is generated by dom node and is generated on document(root node))
        Event happens in 3 stages
            1. Capturing phase  - event going from root/parent(document) elements to target element(on which event listener is attached)
            2. Target phase     - event listening and handled(via event handler fnc) from target element(on which event listener is attached)
            3. Bubbling phase   - after event handler function execution, event again goes to root/parent(document) element, executing handler of parent element(if listener attached)

            Note - defaultly addEventListener() catches event in Bubbling phase.
                 - After target element bubbling can be stopped(event can't be handled by parent elements of target element) using; e.stopPropagation();
                 - to catch event in Capturing phase we can use 3rd argument; addEventListener('click', func, true) 
                 - Event Delegation : attach an event listener to a parent element(using event.target) instead of directly to each child element.
                                    : Event Delegation relies on event bubbling

        const aEventHandlerFnc = (e)=>{}
        a.addEventListener('click', aEventHandlerFnc)       // multiple event handler function can be executed(i.e. a.addEventListener('click', aEventHandlerFnc1), a.addEventListener('click', aEventHandlerFnc2)) // both event handler function will be executed
        a.onClick = aEventHandlerFnc                        // for direct assignment of eventlistener(old), only lastly assigned Event Handler function is executed(i.e. a.addEventListener('click', aEventHandlerFnc1), a.addEventListener('click', aEventHandlerFnc2)) // only aEventHandlerFnc2 is executed     
        <a onclick="aEventHandlerFnc()">Click Here</a>      // html event handler

        a.removeEventListener('click', aEventHandlerFnc) 

        document.querySelector('.btnCheck').addEventListener('click', function(e){ e.preventDefault() })  // eventHandlerFunction(e)
            this === e.currentTarget     // both returns the target element(on which event listener is attached)
            e.target                     // returns the element on which the event is occurred

        Passing 'argument'/changing 'this' keyword value for handler function
            document.querySelector('.btn').addEventListener('click', fn)                // defaultly, 'this' === <button class="btn"></button>
            document.querySelector('.btn').addEventListener('click', fn.bind(obj))      // for returned fun, 'this' === obj

        Intersection Observer API(observe changes of target element intersecting element/viewport)
            const observer = new IntersectionObserver((entries, observer)=>{}, {root: null, threshold: [0,0.1,1], rootMargin:'150px'});    
                                // (entries, observer)=>{observer.unobserve.entry[0].target}
                                // root = element/viewport(null) wrt which target-element is being observed.
                                // threshold = area of root(viewport/element) intersection in % wrt which target-element is being observed
                                                for threshold list, event will trigger at every value from list(as target gets that % area on viewport/element intercepted)
                                // rootMargin = margin to the threshold string value in pixel
            observer.observe(document.querySelector('.section1'))       // target element


    - Handling keyboard events  // global event(should be called on document)
        document.addEventListener('keydown', function(event){       // addEventListener gives the event object which can be used in event handler function
            if (event.key === 'Enter'){}                            // event object will have key property which stores the value of key pressed from the keyboard
        });                                 // 'leftArrow', 'Enter', 'Enter'


    - Local Storage API(key-value store)(blocking storage - if used for large ammount of data application will slowdown)
        localStorage.setItem('key',JSON.stringify(object))  // need two parameters,1.key string and 2.value string(converting object to string)
                                                                using local storage will eraze/rewrite the prototypal inheritance to the Object
        const object = JSON.parse(localStorage.getItem('key'))
        localStorage.removeItem('key')



** Exception handling

        try{

        } catch(exception){
            console.log(exception)
        }



** OOP - 
        - JS does not support Classes, rather all JS objects are linked to prototype object containing all methods and properties using "Prototypal Inheritance" / "delegation"
        - In Js, prototype object method is used for all JS objects linked to that Prototype object
                Eg. all array objects are linked with the "Array.prototype" prototype object
        - whereas in classical OOP with class and instance, methods are copied from class to all instances

    Piller of OOP
        Abstraction - ignore/hiding unrelated details 
        Encapsulation - keeping properties and methods private inside a class(unaccessible outside of class)
        Inheritance - Inherits Parent Class
        Polymorphism - child class overwrites a method it inherited from parent class


    Class - Create Prototype, create object/link Object to prototype
            Classes are not Hoisted
            Class Body always executed in Strict Mode "use strict"

        1. Constructor Functions - technique to create objects from function; built-in objects like Array, Maps or Sets are actually implemented

            const Space = function(planet){        or         function Space(planet){               // arrow function doesn't work
                this.planet = planet;                             this.planet = planet;             // because they don't have 'this'(has their lexical 'this')
                // this.calcDist(){}                              // this.calcDist(){}              // never create method like this, as every object will create its own copy of function. Rather we uses Prototypal inheritance for methods
            }                                                 }
            const earth = new Space('Earth');    // earth.planet = 'Earth'
            console.log(earth instanceof Space)  // true
            Space.prototype.calcDist = function () {}                       // Every function has a property called Prototype on which we can add methods that will be accessible for all objects created using Constructor Functions
            earth.calcDist()                                                // prototypal inheritance/delegation
            Space.calcDist = function () {}                                 // static function

            Space.prototype.galaxy = "Milky Way"                            // properties/attributes can also be set
            earth.galaxy                                                    // "Milky Way"    
            earth.hasOwnProperty('planet')                                  // true 
            earth.hasOwnProperty('galaxy')                                  // false 

            earth.__proto__ === Space.prototype                             // true(due to step 3 of 'new')
            Space.prototype.isprototypeOf(Space)                            // false
            Space.prototype.isprototypeOf(earth)                            // true


            steps happens when we use 'new' keyword on constructor function to create object
                1. new empty object {} is created
                2. function called, and 'this' set to empty object{} created in step one
                3. creates <__proto__> property on {} and links its value to Constructor Function prototype <Space.prototype>
                4. {} returned unless we are explicitly returning something else, generally we should never return from constructor function


            Prototype Chain ⬆ - series of links between objects, linked through prototype(serches for properties and methods in parent __proto__)
                +----------------+      +----------------+
                | Constructor Fun|  ->  |   Prototype    |                  Object() constructor function is used when we use object literal
                |    Object()    |      |Object.prototype|                      i.e. var a = {}   or   var a = new Object(a)
                +----------------+      |__proto__ = null|                  End of Prototype Chain ⬆             
                                        +----------------+
                                                 ⬆
                +----------------+      +----------------------------+
                | Constructor Fun|  ->  |         Prototype          |
                |     Space()    |      |       Space.prototype      |
                +----------------+      |__proto__ = Object.prototype|
                                        +----------------------------+
                                                      ⬆
                                        +----------------------------+      earth.__proto__.__proto__.__proto__ === null
                                        |          object            |      earth.__proto__.__proto__ === Object.Prototype
                                        |          earth             |      earth.__proto__ === Space.Prototype
                                        |__proto__ = Space.prototype |      
                                        +----------------------------+


        2. ES6 Classes           - Class type implementation but behind the scenes it works exactly like Constructor Functions
                                 - Classes are not Hoisted
                                 - Classes are also first-class citizen, just like functions
                                 - Classe body are always executed in Strict mode, ie. 'use strict'
            class Space {
                constructor(planet, isWater){
                    this.planet = planet;
                    this.isWater = isWater          // setter is called/executed 
                }

                // Instance Method
                calcDist() {}

                // getter                           // getter and setter are available for all the objects
                get isWater(){
                    return this._isWater
                }

                // setter
                set isWater(updatedStatus){
                    this._isWater = updatedStatus
                }

                // Static method
                static life(){}
            }
            var earth = new Space('Earth', true);        // earth.planet = 'Earth'
            let water_available = earth.isWater          // getter is called, water_available = true     used as property // earth.isWater()
            earth.isWater = false                        // setter is called, water_available = false                     // earth.isWater(false)
            water_available = earth.isWater              // getter is called, water_available = false



        3. Object.create()       - way of linking an object to a Prototype Object(object from object literal)

            const Space = {
                initFunc(planet, isWater){              // mannual initializer function
                    this.planet = planet
                    this.isWater = isWater         
                }

            }

            const earth = Object.create(Space)          // creates new object from Space with __proto__ = Space.Prototype
            earth.initFunc('Earth', true)                       (behaves like inheritance)


    Inheritance -
        1. Constructor Function

            const Child = function(arg1, arg2){
                Parent.call(this, arg1)                     // calling constructor from Parent with 'this' assigned to Clild class calling obj
                this.arg2 = arg2
            }

            // Inheritance/Linking Prototypes
            Child.prototype = Object.create(Parent.prototype)       // this will create new empty Child object with prototype assigned to Parent.prototype                                                        
                // Child.prototype = Parent.prototype   ->   can't use this as it will create only one Parent.prototype for all objects created with Child class, which should be Child.prototype for Child objects

            const obj = new Child("name","age")
            console.log(obj instanceof Child)       -> true
            console.log(obj instanceof Parent)      -> true     // should be false but giving true because; Child.prototype = Object.create(Parent.prototype)
            console.log(obj instanceof Object)      -> true     // should be false but giving true because; Child.prototype = Object.create(Parent.prototype)
        // To fix above
            Child.prototype.constructor = Child

        2. ES6 Classes - works exactly same as Constructor Function, just syntax is different

            class Child extends Parent{                 // extends keyword automatically set up prototype chain(same working as Constructor Function[prototypal inheritance])
                constructor(parent_arg, child_arg){
                    super(parent_arg)
                    this.child_arg = child_arg
                }
            }
            class Child extends Parent{}

            const obj = new Child("name","age", "canWalk")
            const obj1 = new Child("name","age", "canWalk")     // if not defined default constructor is Parent constructor

        3. Object.create()

            const Child = Object.create(Parent)         // creates a new object with prototype assigned with Parent
            Child.initFunc = function(planet, isWater, life){
                Parent.initFunc.call(this,planet, isWater)
                this.life = life
            }

            const obj = Object.create(Child)        // creates a new object with prototype assigned with Child and Child objects prototype is Parent. Inheritance
            obj.initFunc('Earth', true, true)

    Encapsulation - 
        // Public Class Field (available on instance[not on prototype])
            need = "Transportation";

        // Private Class Field (available on instance[not on prototype])
            #wheels = 4;        // should be defined inside class but outside of function
            #key;               // in case we need private variable initialization in a function, then we define private field in class 
                                    // and then initialize/assign value in that function

        // Public Method (added on prototype)
            getWheels(){                
                console.log(this.#wheels);  // private class fields, only accessible inside of class
            }

        // Private Methods
            #pinVerifier(){
                console.log("pin verifier");
                return true;
            }



** Asynchronous JS - code execution doesn't wait to finish execution of previous line of code
        API(Application Programming Interface) - Determines how one set of software communicates with another set of software
        Web API - application running on server, that receives requests for data and send back the response data
        API data format 
            AJAX(Asynchronous JavaScript and XML) 
                - asynchronous communication(request data) with remote servers dynamically(without loading webpage)
                - XML(AJAX) is just popular name but we don't use xml now we uses JSON(javascript object converted to a string)


    Old JavaScript API request
        const req = new XMLHttpRequest();   
        req.open('GET', 'https://github.com/sprculguy/programming.git')
        req.send()                                      // load event will trigger after getting the response
        req.addEventListener('load',function(){                 
            const [data] = JSON.parse(this.responseText)        // converting JSON string to object
        })  


	Old Promise.then() -
        - An object that is used as a placeholder for the future result of an asynchronous operation
        - Container for an asynchronously delivered(in future) value. e.g. response from AJAX call
        - Promise Life Cycle:
            1. Pending - before future value is available
            2. Async task
            3. Settled - after async task is finished.
            Note - Promise is only settled once
        - we can create a promise object
            e.g.    cosnt promiseObj = new Promise(function(resolve, reject){        // only one argument - executer function gets executed with promise constructor by passing two function arguments (resolve, reject)
                        setTimeout(function(){                                       // adding setTimeout to make function asynchronous nature
                            if(success==true) resolve('response')
                            else reject(new Error('error'))
                            }
                            , 2000)
                    })
                    promiseObj.then(res=>res).catch(err=>err)
        - promisifying callback (setTimeout),
                    const wait = function(seconds){
                        return new Promise(function(resolve){setTimeout(resolve, seconds*1000)})
                    }
                    wait(2).then(()=>{
                        console.log('waited for 2 seconds')
                        return wait(1)
                    }).then(()=>{console.log('waited for 1 seconds')})
        - Promise.resolve('response').then(res => res)
        - Promise.reject('error').catch(err => err)
        - Promise.all([])       // args - array of promises to execute them parallelly, returns - array of response(resolve) promise objects.  
                                    // in case of any one of the promises reject, then promise.all() will be rejected
        - Promise.race([])      // args - array of promises to execute them parallelly, returns - first settled(resolve/reject) response promise objects 
        - Promise.allSettled([])// args - array of promises to execute them parallelly, returns - array all settled(resolve/reject) response promise objects 
                                    // difference between Promise.all() & Promise.allSettled() is Promise.allSettled() will return all the results(resolve/reject) in both cases
        - Promise.any([])       // args - array of promises to execute them parallelly, returns - only first resolved response promise objects, ignoring failed/rejected responses of before that first resolve


    Latest fetch API request/promise
        const req = fetch('https://github.com/sprculguy/programming.git', optionalOptionsObj)    // req -> promise Object  |  optionalOptionsObj = {method: "POST", body: JSON.stringify({username: "example", etc. })}	// default method="GET"
        req.then(function(res){return res.json()}).then(function(data){console.log(data)})
        req.then(res => res.json(), err => alert(err)).then(data => data)               // using then again as json() also returns promise object
        req.then(res => {
            if(!res.ok)
                throw new Error(`error is ${res.status}`)                               // manual error throw for 404 response
            return res.json()
        }).then(data => data).catch(err => alert(err)).finally(()=>loading_cursor.style.display = None)         // error can be handled as above line(rescallback, errcallback) or this catch()
                                                        // catch also returns promise object that's why we can use finally


    Async/Await - advance way of consuming/using promises. In background everything
        - creates a function be executed asynchronously(in Web APIs environment without blocking call stack) and return a promise
        - async/await are just implementation because behind the scenes it works exactly like consuming promises using fetch().then()
                eg. const fun = async function(){
                        try{
                            const res = awaits fetch('https://github.com/programming.git')            // fetch('https://github.com/programming.git').then()      
                            return res              // stops the execution of function(which is being executed asynchronously in Web APIs environment without blocking call stack) until promise is fulfilled
                        }catch(err){
                            console.error(err)
                            throw err
                        }
                    }    

                    (async function(){                                  // <script src="js/asynchronous.js" defer> </script>
                        try{                                            // if this code gives error try force reload - Ctrl + Shift + R
                            const res = await asyncFunc()
                            console.log(res)
                        }catch(err){
                            console.error(err)
                        }
                    })()
                    OR
                    try{                            // await is only valid in async functions and the top-level bodies of modules
                        const res = await fun()       // so, <script type="module" src="js/asynchronous.js" defer> </script>
                        console.log(res)              // top-level await is synchronous(blocks the module code execution)
                    }catch(err){
                        console.error(err)
                    }

            // use case of Promise.all([])
                const imgs = [].map(async img => await createlmage(img))        // returns promise objects
                const imgsEl = await Promise.all(imgs);                         // promise objects resoled to values    
                console. log(imgsEl) 
                imgsEl. forEach(img = img.classList.add('parallel')):



** Error Handling - 
    try{
        throw new Error('myError')
    }catch(e){
        console.error(e)
    }finally(){

    }



** Modern JS development -

    Module1                 |                                                                           |
    Module2                 |   |                                                                       |
    .                       |     -->        Bundling        -->          Transpiling/Polyfilling       | --> JavaScript Bundle
    .                       |             (Join modules)            (JS Modern to Primitive conversion) |
    React package(from NPM) |             Parcel/webpack                           Babel                    |
    ------------------------+---------------------------------------------------------------------------+-----------------------
        development                                        Build Process                                          Production


            ES6 Module          |      Script
    ----------------------------+--------------------------    
        Scoped to module        |      Global               <-     Top-level variables 
           Strict Mode          |    Sloppy Mode            <-     Default Execution Mode
            undefined           |   window object           <-     top-level 'this' 
               Yes              |        No                 <-     Import/Export top-level(outside of any block)
       <script type="module">   |     <script>              <-     HTML linking
            Asynchronous        |   Synchronous(blocking)   <-     Default file downloading(unless using defer/async attribute in <script>)



** Import/Export 
    - HTML linking should be with <script type="module">
    - all imports are hoisted
    - Modules are imported Synchronously(main code(index.js) is executed only after all imported modules are downloaded and executed)
    - imports are not copy of exported variables but are reference(points to the same place in memory) 
    - there are two types of ES6 export/imports
        1. Named export/import
            import { var1, var2 as variable } from "./fuctionContainer.js"
            import * as x from "./fuctionContainer.js"
            console.log(x.var1)

            export { var1, variable as var2 };
            export const x = 10;

        2. Default export/import 
            - exports/imports one thing/value per module

                import x from './fuctionContainer.js'

                export default function(){}
                export default "234567890987654"

    - CommonJS export/import
        - Developed for Node.js(requre() function & export object is not available in browser but are available in Node.js)

            const { x } = require("../fuctionContainer.js)  

            export.x = function(){}



** To create a full-stack application/project with npm
    run npm init
    npm install express mongoose dotenv                 // dependencies{} in package.json
    npm install nodemon -D                        // dev devDependencies{} in package.json

        e.g. package.json
                {
                    "name": "project-name",
                    "version": "1.0.0",
                    "description": "",
                    "main": "index.js",
                    "scripts": {
                        "dev": "NODE_ENV=development nodemon backend/server.js",
                        "build": "npm install && npm install --prefix frontend && npm run build --prefix frontend",
                        "start": "NODE_ENV=production node backend/server.js"
                    },
                    "type": "module",
                    "keywords": [],
                    "author": "",
                    "license": "ISC",
                    "dependencies": {
                        "dotenv": "^16.4.5",
                        "express": "^4.19.2",
                        "mongoose": "^8.5.1"
                    },
                    "devDependencies": {
                        "nodemon": "^3.1.4"
                    }
                }
