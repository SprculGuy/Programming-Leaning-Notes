Brenden Ike in 1995 (Internationally standard for JavaScript language = ECMAScript) (European Computer Manufacture Association) 
                                                        ECMAScript is the specification describing how browsers should implement and interpret JavaScript.
            ES 5 -> 2009
            ES 6 -> 2015   Biggest update after which every year JS gets updates
            JS is Backward compatible, even with ES1(1997)

            Js is functionality/behavior for Components of webpage
            


**Characteristics of Js
            High Level - no need to manage memory with variable definition as c/c++
            garbage collected
            Just in time compiled (compiles and executed immediately)
            multi paradigm (can be imperative or declarative paradigm) - supports procedural/function/object-oriented paradigm
            Synchronous
            Single threaded
            Prototyped based oopl(has no class, object is created from another object)
            dynamically typed

            First-class function(function can be treated as variable) 
            Non-blocking event loop concurrency model(executes time-consuming tasks in background and takes them back in main thread as they finished)
            Everything in js happens inside an Execution Context

    Typescript  - JavaScript's superset with additional feature implementation(script.ts)
                - TypeScript adds static typing to JavaScript, which can help catch errors during development and improve code maintainability.
                - Needs TypeScript compiler (tsc) to transpile it into JavaScript.

    JavaScript framework
            ReactJS - use JSX(JavaScript XML) which simplifies mixing of js and html
            vueJS - 
            AngularJS -
        native mobile applications    
            React Native - 
            Ionic -        
        Native Desktop Application
            Electron - Electron embeds Chromium and Node.js to enable web developers to create Cross Platform desktop applications.

    JavaScript Build tools - comes js framework with to convert/optimize the code back into js for current browser
                            - converting ES6+ JavaScript to older versions for broader browser compatibility
            1. npm - comes with Node.js    Node.js is to execute JavaScript code server-side
            2. webpack
            3. gulp    



**Types to apply JS/Script to webpage -    
    1> Internal - used anywhere inside the <html> and only applies to current html document
            <script>
                const allp = document.querySelectorAll("p")             // ; at ending is optional
                                                                        // '' or " " either can be used according to our preference.
                for(let item of allp){
                    item.innerHTML = "item.innerHTML"
                }
            </script>

    2> External -
            <script src="js/script.js"></script>            // scripts fetched and executed in priority by halting the document(html/css) loading. i.e why should be used at the end of Body tag/element

        or  <script defer src="js/script.js"></script>      // scripts are fetched parallel to document but executed only after loading of document is finished. 
                                                            // 'DOMContentLoaded' event only fires after script execution(even if document fetched completely before script fethed/executed), 
                                                            // scripts are executed in order they are declared in code

        or  <script async src="js/hello-world-alert.js"> alert("Hi") </script>      // only the external js code will be executed, internal js will be ignored
                                                            // scripts fetched parallel to document and executed after fetched by halting the document loading. 
                                                            // 'DOMContentLoaded' event fires as soon as document fetched completely(even if script fethed/execution is not complete)
                                                            // scripts not guaranteed to execute in order they are declared in code, scripts gets executed in the oreder it fetched

            <script type="module" src="js/script.js"></script>      // when type attribute set to module, script tag get automatically becomes defer



**Execution of JS-->                                                
	SourceCode -> Parsing & syntax Checker -> AST -> Just in-Time Compilation(BrowserEngine/node) -> Machine language -> Execution(using call stack) -> Global Execution Context + EC of function as they were called + EC of callback function after using event loop             
                                                    ^ >     gives unoptimized version as fast as possible then          |
                                                    |  in background the code is optimized(recompiled) while execution  |               // these 3 threads are completely separate from the main thread that
                                                    |<    uses 3 separate threads(Parsing,compilation,optimization)    <|                               is running into the call stack executing code
    1. Parsed(analyzing and converting a program into an internal format that a runtime environment can actually run) into a data structure called AST(Abstract Syntax Tree)
                    AST example for code; const x = 23;
                        VariableDeclaration { 
                            start: 0
                            end: 13
                            declarations: [
                                variableDeclarator {
                                    start: 6
                                    end: 12
                                    id: Identifier {
                                        start:6
                                        end: 7
                                        name: "x"
                                    }
                                    init: Literal = $node {
                                        start: 10
                                        end: 12
                                        value: 23
                                        raw: "23"
                                    }
                                }
                            ]
                            kind: "const"
                        }
	2. AST is compiled and converted as well as executed immediately, an unoptimized version of machine code for fast execution.
	3. Then the unoptimized machine code is recompiled again and again without stopping already running execution to make the machine code optimized.
	4. Parsing, Compilation/Recompilation & and Optimization is done on separate threads which is completely separate from the main thread
	5. Main thread swept away old unoptimized code and re-executes new optimized machine code again and again
    6. After getting the Machine Code, one "Global Execution Context" is created(for code outside of any Function) and JS code is executed inside of execution
    7. as the function call is executed, new function specific execution context is created and added to call stack of JS engine.
    8. After execution of top-level JS code, for all the callback functions execution contexts are created and those functions are executed inside of particular execution contexts
    9. Global Execution Context remains in call stack as long as browser is running.



** JavaScript Runtime in Browser -

    +---------------------------------------------------------------------------+
    |                           JS Runtime in Browser                           |
    |                                                                           |
    | +---------------------------+   +---------------------------------------+ |
    | |         JS Engine         |   |              Web APIs                 | |       - Web APIs is the functionalities provided to the JS engine accessible on windows object  
    | |                           |   |  +---+   +------+   +---------+       | |       - Web APIs are not the part of JS language, but the part of JS Runtime
    | | +----------+ +----------+ |   |  |DOM|   |Timers|   |Fetch API|  ...  | |
    | | |          | |          | |   |  +---+   +------+   +---------+       | |
    | | |          | |  CALL    | |   +---------------------------------------+ |
    | | |   HEAP   | |  STACK   | |                                             |
    | | |       *  | |          | |      +---------------------------------+    |
    | | | *        | | __F2EC__ | |      |            Callback Queue       |    |       - Callback queue is a data structure that contains all the callback functions that are ready to be executed
    | | |    *  *  | | __F1EC__ | |      |  +-----+  +-----+  +----+       |    |          example; eventHandlerFunction - callback function from DOM event listener
    | | |  *   *   | | __GEC___ | |      |  |click|  |timer|  |data|  ...  |    |                      as soon as 'click' event happens in the DOM, eventHandlerFunction() defined in the addEventListener gets added to callback queue.
    | | +----------+ +----------+ |      |  +-----+  +-----+  +----+       |    |                      then when the call stack is empty the callback queued function passed to call stack for execution, this happens using 'Event Loop'
    | +---------------------------+      +---------------------------------+    |
    |                                                                           |
    +---------------------------------------------------------------------------+



** JS Engine: A JavaScript engine is simply a computer program that receives JavaScript source code and compiles it to the binary instructions (machine code) that a CPU can understand.
                    JavaScript engines are typically developed by web browser vendors. Examples: V8 engine for Google chrome, SpiderMonkey for Firefox, and Chakra for Internet Explorer.

            Contains; 
                    1. call stack - responsible for code execution using "Execution Context", gets the stack of Execution Contexts
                    2. heap - unstructured memory pool to store the objects memory



** EXECUTION CONTEXT - 
            Browser can't understand high-level JS so the js code from web pages is sent to Browsers JS Engine that creates Execution context(environment) for execution
                during runtime, it's like a box where all the necessary information(local variables) for code execution is stored
            Execution Context consists of;
                    1. Variable Environment
                            - let, const, and var declarations
                            - Function
                            - argument object(arguments that were passed to the function that the current execution context belongs to)
                    2. Scope chain - lexical 
                    3. 'this' keyword  
                            - method -> 'this' = <object that is calling the method>       
                            - function expression -> 'this' keyword refers to the global object(windows in browser). that is problematic, 
                                    so to avoid this 'use strict' should be used so that 'this' object for function expression will point to undefined
                                        'this' = undefined  // in 'use strict' mode 
                                    otherwise;
                                        'this' = <windows>  // without strict mode, (in the browser)
                            - arrow functions -> doesn't get argument object and 'this' keyword in their execution context rather they can use this functionality from their closest normal function parent
                                        'this' = <this of parent scope (lexical 'this')>
                            - eventHandlerFunction() -> 'this' = <DOM element that event is attached to>
                            - new, call, apply, bind -> 'this' = _____



'use strict';   // literal expression used at most start of the script to execute that script in strict mode which provide highlighting and prevention of errors
debugger;       // keyword used to add breakpoint for the debugging



Statement vs Expression:
        code that doesn't produce/return any value on successful execution is statement(s)
            e.g. const x = `this variable declaration is statement as it doesn't return any value`

        code produces/return a value is expression(s)
            e.g. `this is an expression`



**OPERATORS--(with precedence)
		Operators in the same box have the same precedence
		Operators in the same box group left to right
		comparisons, membership tests, and identity tests, all have the same precedence and have a left-to-right chaining

        |***	OPERATORS (with precedence)						        |	***		DESCRIPTION

        |(expressions...), [expressions...],						    |	Binding or parenthesized expression, list display,
        |{key: value...}                    							|	object display

        |x[index],                              					    |	Subscription,
        |x(arguments...), x.attribute								    |	call, attribute reference

        |x++, x--													    |	pre-increment, pre-decrement
        |++x, --x													    |	post-increment, post-decrement
        |x+=2, x*=5                                                     |   compound Assignment with augmented expression
        |**															    |	Exponentiation 
        |+x, -x, ~x													    |	Positive, negative, bitwise NOT
        |*, /, //, %												    |	Multiplication, division, floor division, remainder 
        |+, -														    |	Addition/concatenation and subtraction
        | &&													        |  	Logical AND // used on any data type and returns any data type
        |                                                                       // 3 &&'A'      returns 'A'       // returns last truthy value
        |                                                                       // 2 && 3 && 1  returns 1           
        |                                                                       // ''&& 0       returns 0         // returns first Falsey value(short circuiting)
        |                                                                       // 1 && '' && 2 returns ''          
        | ||  												            |	Logical OR  // used on any data type and returns any data type
        |                                                                       // 3||'A'    returns 3       // returns first truthy value(short circuiting)
        |                                                                       // ''||'A'   returns 'A'     
        |                                                                       // ''||0||1  returns 1
        |                                                                       // ''||0     returns 0       // returns last Falsey value
        | !															    |	Logical NOT
        |<, <=, >, >=, !=, ==				                            |	Comparisons (does type conversion)
        |===, !==                                                       |   strict equality operator;  doesn't allows type coercion.eg, 3=='3' is true but 3==='3' is false
        | ??														    |	Nullish Coalescing Operator, x1 ?? x2   // returns x2 if x1 is nullish(null or undefined) Nullish values are null and undefined (not "" or 0)
        |                                                                       // const guest = 0;         Nullish Coalescing operator is same as or(||) operator
        |                                                                       // noOfGuestPresent = guest || 10   // this gives 10 even if the number of guest is 0
        |                                                                       // noOfGuestPresent = guest ?? 10   // this solves above problem and gives value zero, not 10
        |?.                                                             |   Optional chaining operator;  // returns nullish values if doesn't find value to left else executes right-side expression(obj?.property or arr[0]?.property)   
        |                                                                       // obj.property1?.property11  // checks if property1 exists then executes expression otherwise returns nullish value(undefined)
        |                                                                       // obj.method?.() ?? 'method not exist'  // if method doesn't exists then it was returning undefined(nullish value), to avoid this we use nullish Coalescing operator
        |                                                                       // arr[0]?.property ?? 'object array is empty'   
        | ...                                                           |   Spread operator(seperate away - used RHS of '=')(for iterables(string, arrays, maps, sets) but NOT OBJECTS) eg. ...arr
        |                                                                       // x = [1,2,3]  then, ...x = 1, 2, 3 and [1, ...x] = [1, 2, 3]
        |                                                                       // s = "Ank"    then, ...s = 'A', 'n', 'k' and [...s] = ['A', 'n', 'k']
        |                                                                   Rest Operator(groups together - used LHS of '=') eg. function(...args){}    // args = [parameters seperated by commas]
        |                                                                       // x = [1,2,3,4]  then, const [a, ,...remaining] = x; a=1, remaining=[3,4] 
        |                                                                       // obj = {'mon':1,'tue':2,'wed':3}      then, const {mon, ...otherDays} = obj; mon=1, otherDays = {'tue':2,'wed':3}
        | ` Hi my name is ${name},                                      |   Template Literal - Multiline + Formatted string
        |   I am ${age} years old. `

        |\                                                              | Escape character for escape sequences; \',\",\\,\n,\t,\b
        |//														        |- Comment
        |/* 														    |- Multiline Comment 				
        |_block_														|
        |*/															    |    



** DATA SOURCES --
        1. Source Code  - written in source code (eg. status messages)
        2. UI           - user input from DOM (eg. tasks from TODO, etc.)
        3. Web API      - data fetched from web API (e.g. whether data, data about movies, currency conversion rates, etc.) // generally in JSON
        
        JS has total of 6 built-in data structures,
            Array - ordered data, easy manipulation/fetching
            Set - unique items(removes duplicates), high-performance(as searching/deleting is faster than arrays)
            Object - keys must be strings, easy to write and access, used when want to include methods(and has 'this') or working with JSON
            Map - better performance(than objects), easy to iterate & compute size, keys can have any data type value
            Weak-maps 
            Weak-sets



** DATA TYPES--(Dynamically typed languages - variable types are decided in the runtime)
            Primitive - gives duplicate when copied | stored in stack | no methods
                number  (NaN is also of number type) - all numbers are represented as floating point numbers internally in 64 bit binary format(i.e. 24 === 24.0 => true)
                string
                boolean
                null
                undefined(undefined is both value and type of value)
                symbol(values that are unique and unchanged)
                BigInt(larger values than number type can hold) let big = 7445676536389867646n or BigInt(2)

            Reference - [] () {} - gives reference when copied | stored in heap | have methods
                arrays, functions, collections, dates, and all other types of objects
                    - To copy the reference variables, use spread(...) operator - spread operator gives all the elements without creating new variable
                        arr = [1,2,3,4]
                        arrCopy = [0, ...arr, 5]                       // ...arr = 1, 2, 3, 4      ||      arrCopy = [0, 1, 2, 3, 4, 5]
                        obj = {1:"One",2:"Two",3:"Three",4:"Four"}
                        objCopy = {...obj}  || 
                        objCopy = Object.assign({}, obj)         // gives shallow copy, as only first level properties are copied, 
                                                                        if any property is object, that property will be pointing to the same memory location for both the obj and objCopy
            Note - JavaScript converts primitive strings to string objects, so that it is possible to use string object methods like, str.length

        Variable Declaration-   
                var name;                     // var has function scope             // can be redeclared and reinitialized multiple times
                let name;                   |                                       // can't be redeclared
                const name = "Ankit";       | // let and const has block scope      // must be initialized with declaration only, redeclaration is not allowed
                typeof x;                     // Gives the type of the x variable/value
                        for example.
                                function Numbers(){
                                    for(var i = 1; i < 11; i++){
                                        console.log(i)
                                    }
                                    console.log(i)           // gives i = 11 as 'var' variable 'i' is scoped in parent function(Numbers()) block. 
                                }                                 // ie, can be used anywhere inside Numbers() function.

                                function Numbers(){
                                    for(let i = 1; i < 11; i++){
                                        console.log(i)
                                    }
                                    console.log(i)          // gives reference errors, as let variable 'i' is only scoped inside 'for' block
                                }

        Number - (NaN is also of number type) 
            - all numbers are represented as floating point numbers internally in 64 bit binary format(i.e. 24 === 24.0 => true)
            - out of 64 bit, only 53 bits are used for numbers rest bits are used for position of decimal point and sign(-/+)
            - Number.MAX_SAFE_NUMBER    => max number value that is stored in js number variable
            - Numberic Seperator (1_23_456 => 123456) should be like 1_1 and not 1._ _1

                Number Methods - 
                    Number.isNaN(x)         // to check if x is NaN value
                    Number.isInteger(x)     // to check if x is integer value
                    Number.isFinite(x)      // to check if x is number/floating value(and not infinite i.e. 1/0)

                    Math.sqrt(4) === 4**(1/2) === 8**(1/3)      => 2 === 2 === 2
                    Math.max(2,56,"87",12,34,9)                 => 87     // Type Coercion (internally convert string to number)
                    Math.min("2",56,"87",12,34,9)               => 2      // Type Coercion (internally convert string to number)

                    Math.PI                                     => 3.14
                    Math.random()                               => x      // 0 < x < 1
                        - Math.trunc(Math.random()*6)           => 0 to 5
                        - Math.trunc(Math.random()*(6-2)) + 2   => 2 to 5
                    
                    Math.trunc(3.14) === Math.trunc(3.94)       => 3 === 3
                    Math.trunc(-3.14) === Math.trunc(-3.94)     => -3 === -3
                    Math.floor(3.14) === Math.floor(3.94)       => 3 === 3
                    Math.floor(-3.14) === Math.floor(-3.94)     => -4 === -4
                    Math.ceil(3.14) === Math.ceil(3.94)         => 4 === 4
                    Math.round(3.14) !== Math.round(3.94)       => 3 !== 4     

                    `2`.padStart(3, 0)                          => 002
                    (3.14).toFixed(0) !== (3.94).toFixed(0)     => 3 !== 4  // returns string
                    (3.14).toFixed(3)                           => 3.140    // returns string
                    +(3.145).toFixed(2)                          => 3.15    // returns string so to convert into number we are using +

        String -
                const s = "string" / 'string'
                const s = `this is ${expression}
                            string`
                
                String Methods - strings are immutable so all methods return new strings 
                    s.length;
                    s[s.length - 1]         -> last character
                    s.at(-1)                -> last character
                    s.indexOf("g")          -> 5    for s="string"      // gives first occured characters index
                    s.lastIndexOf("ng")                             // gives last occurence character index
                    s.includes("string")    -> true/false
                    s.startsWith("s")       -> true/false
                    s.endsWith("g")         -> true/false
                    s.slice(1, -1)                                  // return the string from index 1st till second last character(as 2nd index is exclusive)
                    arr = s.split(" ")      -> array of s words spitted by " "
                    new_s = arr.join(" ")   -> all elements from arr joined by " " to create a string         
                    s.toLowerCase()
                    s.toUpperCase()
                    s.trim()                                        // trims the white spaces both from start and end
                    s.trimStart() s.trimEnd()
                    s.replace(" ", "space")                         // replaces first occurence of " " to "space" and returns string
                    s.replaceAll(" ", "space")                      // replaces all occurences of " " to "space" and returns string

                    Regular Expression - 
                        s.replace(/" "/g, "space")                     // regular Expression with (/''/g) Global Flag so All the Occurrences Are Targeted           

        Object -
                var a = {};     // Blank Object
                // Filled Object
                const backpack = {                                  // can change the properties of object but can't reassign all properties of backpack container/variable
                                name: "Everyday Backpack",                                      for ex. > const x = {'1':'One', '2':'two'}
                                volume: 30,                                                             > x = {'1':'One', '2':'two'} // will give error
                                color: ["grey", "blue"],
                                "pocket Num": 15,
                                strapLength: {
                                    left: 26,
                                    right: 26,
                                },
                                lidOpen: false,
                                toggleLid: function (lidStatus) {                           // toggleLid is the method of backpack object
                                    this.lidOpen = lidStatus;                               // 'this' keyword refers to caller object
                                    updateBackpack(`Lid status changed.`);
                                },
                                newStrapLength(lengthLeft, lengthRight) {                   // same as; newStrapLength : fuction(lengthLeft, lengthRight) {}
                                    this.strapLength.left = lengthLeft;
                                    this.strapLength.right = lengthRight;
                                    updateBackpack(`Strap lengths updated.`);
                                    console.log(this);                                         // logs whole object from which the 
                                },
                            };

                backpack.name
                backpack["pocket Num"]                      // usable if object property has space in its name, same as 'backpack.pocket Num'
                backpack.color[0]

                backpack.hasOwnProperty("lidOpen")          // returns true
                delete backpack.name
                backpack?.size                              // doesn't gives error even if size is not property of backpack

                Object Method/Properties - 
                    var obj = { 1:"One", 2:"Two" }
                    delete obj.2;           // obj becomes { 1:"One" }

                    Object.keys(obj)            // gives all keys array
                    Object.values(obj)          // gives all values array
                    Object.entries(obj)         // gives all keys and values arrays     // this methods converts objects to maps 

        Arrays (objects that treated differently) -
                var a = [12,13];            a[0] = 12       a is converted to object;ie. a = {0:12, 1:13}
                                                            so we can assign negative index mannualy, a[-1] = 11
                const a = new Array(1,2,3,4)        // using constructor function
                const a = new Array(5)                  // a=[ empty*5 ] & a.length = 5  i.e. creates empty array with size 5
                a.fill(0, 2,3)                              // a=[ empty*2, 0, empty*2 ]  mutates 'a'
                const a = Array.from({length:5}, (cur, i) => i+1)               // a=[1,2,3,4,5]
                const a = Array.from(nodeList, element => Number(element.textContent))    
                const a1 = [1,2,3,4]
                
                a1[0]               |// gives 1(first element)
                const [a] = a1      |   a = a1[0]
                a1.at(0)            |

                a1[a1.length - 1]   |// gives 4(last element)
                a1.slice(-1)[0]     |
                a1.at(-1)           |

                a1[0] = 5    // allowed as changing element is possible for non-primitive variables
                a1 = [6,7,8,9]    // not allowed as a1 is const
                
                const a3 = [a1, `Ankit`, lastName, 2024-2001]
                
                a3.indexOf(`Ankit`)     // returns 1
                a3.indexOf(`Ankita`)     // returns -1
                
                a3.includes(`Ankit`)     // returns true    uses strict equality (===)
                a3.includes(`Ankit`)     // returns false

                Array Methods - 
                    a.length                                                 -> number of elements in array
                    
                    a.at(-1)                                                 -> last element
                    a.indexOf(value)                                         -> index / -1
                    a.findIndex(function(current, i, a){return true/false})  -> returns first element index for which callback function return true of array elements
                    a.find(function(current, i, a){return true/false})       -> returns first element for which callback function return true of array elements
                    
                    a.includes(12)                                           -> true/false      // checks for eqality
                    a.some(function(current, i, a){return true/false})       -> true/false      // checks for availability
                    a.every(function(current, i, a){return true/false})      -> true/false      // if callback function return true for every value of array 

                    a.concat(a1)                                             -> [...a, ...a1]
                    a.join("")                                               -> string with all 'a' elements

                    a.flat() / a.flat(1)    // if a=[[1,2],3,[4,[5,6]]]      -> [1,2,3,4,[5,6]]     // flat one level nested array
                    a.flat(2)               // if a=[[1,2],3,[4,[5,6]]]      -> [1,2,3,4,5,6]       // flat 2 levels nested array
                    a.flatMap((x, i, a1) => x.array)           // map + flat

                    a.reverse()                             reverse 'a' elements as well as return new reverse elements array too
                    a.sort()   // sort array elements according to strings   -> sorted array in ascending order with original array mutation
                    a.sort((a,b)=> a-b)     ascending   // if callback function returns negative value, a and b gets swapped in array
                    a.sort((a,b)=> b-a)     descending  

                    a.push(14)          add at the end
                    x = a.pop()         remove form the end and return last value
                    a.unshift(11)       add at the start
                    x = a.shift()       remove from the start and return first value
                    
                    x = a.slice(start)  
                    x = a.slice(3)          returns new array from 3rd index element, without changing 'a'
                    x = a.slice(-2)         returns new array from 2nd last index element of 'a', without changing 'a'
                    x = a.slice(start,end)  excluding 'end' index
                    x = a.slice(1, 3)       returns new array with 1st index till 2nd index, without changing 'a'

                    x = a.splice(index)    
                    x = a.splice(3)         returns new array from 3rd index element and also remove them from 'a'
                    x = a.splice(index, number)
                    x = a.splice(1, 2)      remove 2 values from 1st index of 'a' and return remaining elements in x

                    sqInt = a1.filter((num, i, a1) => Number.isInteger(num) && num > 0).map((x, i, a1) => x*x);   // map method creates new and forEach doesn't
                                            // filter the value based on true/false returned by callback function(filter function argument)
                    sum = a1.reduce((accumulator, current, i, a1) => accumulator + current, 0)          // sum = 10 / 0(accumulator initial value)   // a1 = [1,2,3,4]

                    a.entries()       -> map with index and values arrays       // this methods converts array object to maps
                    a.forEach(function(item, index, a){})       // changes done in temporary copy of arr  |  break/continue can't be used


        Sets (iterable) - collection of unique values // no way to retrieve value using index/method but can be iterated
                const set = new Set("Any iterable ")                     iterables are - string, arrays, maps, sets
                        // set = {'A','n','y',' ','i','t','e','r','a','b','l','e'}
                
                Set Methods -
                    set.size        gives length of set values
                    set.has('A') -> true/false
                    set.add('A')
                    set.delete('A')
                    for(const item of set) console.log(item)
                    set.forEach(function(item, item, set){})       // changes done in temporary copy of set  |  break/continue can't be used

        Maps - key-value pairs where the keys can be any datatype(for objects, must be strings) and ordered by intersection
                const fruits = new Map([                            fruits = {                                                            }
                                            ["apples", 500],                    "apples" => 500,
                                            [[1,2,3], 300],                     [1,2,3] => 300,
                                            [{1:'a'}, 200]                      {1:'a'} => 200
                                        ]);  {                               }
                Map Methods -
                    fruits.set(arr, "Test"); => whole map    //adding or changing existing map value
                    fruits.get(arr)
                    fruits.has("apples")  => true/false
                    fruits.delete("apples")
                    [...fruits]                     // convert map to array
                    [...fruits.keys()]              // convert map to map keys array
                    [...fruits.values()]            // convert map to map values array
                    map.forEach(function(value, key, map){})       // changes done in temporary copy of map  |  break/continue can't be used

        Truthy, Falsey and Nullish values
                Falsey values - 0, false, undefined, null, NaN(invalid number/not a number), ``, document.all
                Truthy values - other than Falsey values
                Nullish values - undefined, null     // used with Nullish Operator(??). i.e. (x ?? y) -> returns y if x is nullish otherwise returns x



Date/Time/Time Zone
    const nowUTC = new Date()                                                   => 2024-01-01T00:00:00.000Z  (Object)
    const now = new Date(new Date().getTime() + 5.5*60*60*1000).toJSON()        => 2024-01-01T00:05:30.000Z  (string)
    Number(now) == +now                 => 1725277002705    (mili seconds, reference to 1970-01-01T00:00:00.000Z)
    
    const daysSubstraction = (new Date(2024, 8, 23) - new Date(2024, 7, 23)) / (1000*60*60*24)

    const day = now.getDate()          
    const month = now.getMonth() + 1      // because, jan == 0 && dec == 11
    const year = now.getFullYear()
    const hour = now.getHours()
    const min = now.getMinutes()



Timers - 
    const timer = setTimeout(function, 5*1000, arg1, arg2)          // calls function with arguments after 5 seconds/5000 miliseconds, as 1 sec = 1000 mili
    clearTimeout(timer)                                             // abort the callback of timer

    const intervalTimer = setInterval(function, 5*1000, arg1, arg2) // calls function with arguments after every 5 seconds/5000 miliseconds again and again
    clearInterval(timer)



** Parsing - Type conversion (explicit with functions)
        parseInt(" 34$ ")     Number("34")                              returns 34      // parceInt argument should be starting with number
        parseInt("f")       Number("f")                                 returns NaN 
        parseFloat(" 34rem ")                                           returns 34
        String(12)                                                      returns "12"
        12.toString()                                                   returns "12"
        5.toString(2)                                                   returns "101"
        Boolean("0")                                                    returns true
        Boolean(0)                                                      returns false



** Type Coercion - Js implicit type conversion
        Unary Operator 
            let y = "5"         string
            let x = +y          number
            let z = "A"         string
            let x = +z          invalid number(NaN)  

        Binary Operator
            all expression rather than +(concatenation) Operator converts strings into number
                e.g. x = 5 + "7"     "57"
                    x = 5 - "7"     -2
                    x = 5 * "7"     35



**Destructuring Operator - short form to assign object property values to the variable
        [y, x] = [x, y]             // swapping values of two variable

        const arr = [1, 2, [3, 4]];
        const [x, , y=0, z=0] = arr;        // x=1, y=[3, 4], z=0       // with default value
        const [x, , [y, z]]                 // x=1, y=3, z=4

        obj = { 
            property1 : {
                property11 : value11,
                property22 : value22
            },
            property2 : value2
        }
        const { property2 } = obj;                                                      // property2 = value2
        ({ property2 } = obj)                                                           // property2 = value2
        const { property2 : x=[], property1 : {property11 : y, property22} } = obj;     // x = value2, y = value11, property22 = value22
        const { property3 : z=[] }                                                      // z = []           // with default value



**HOISTING - variables and functions are hoisted i.e. only their declaration (var a;) is added to the execution context of script in memory
        because of hoisting,
            - 'var' and functions are hoisted in global space and are assigned to "undefined"
            - 'let' and 'const' are accessible only after initialization as they are hoisted in separate memory(that is reserved for the block) space,
                    so they will give "ReferenceError" if accessed before initialization, before initialization they are in TDZ(Temporal Dead Zone)

        Exceptions
            NullPointerException (NPE) is an error that occurs when a program tries to access or manipulate data
                through a reference that points to a non-existent object or has a null value.
            The equivalent error is a TypeError when accessing properties or methods of null or undefined objects.

                                    |    Hoisted     |             Initial value               |     Scope     |
        ----------------------------|----------------|-----------------------------------------|---------------|
        Function Declaration        |      Yes       |            Actual Function              |     Block     |                                  
        var variable                |      Yes       |               undefined                 |    Function   |                          
        let, const variable         |       No       |   <uninitialized>, Temporal Dead Zone   |     Block     |                                  
        function expression/arrows  |cant use before initialization as variable is hoisted with value undefined|



O/P-I/P
    console.log(`outputs to console`)
    console.dir(r)
    console.warn()              
    console.error()                 
    console.table(object)                       // gives key-value rows in table on console
    alert(`browser provided notification window`);
    prompt(`// gives pop-up windows with input field and returns input string`);



**Conditionals - 

        IF
            if() {}
            else if() {}
            else{}

        SWITCH
            switch(char) {           
                case 'a':           
                    __statement__       // multiple statements can be used without {}.
                    __statement__
                    break
                case 'b':               // if the value is 'b' or 'c' code of c will be executed.
                    __statement__
                case 'c':
                    __statement__
                    break
                default:
                    console.log(`Not a valid character!`)
            }



**Ternary Operation - 

        condition ? statement-if-true : statement-in-false

        condition1 ? statement1-if-true: condition2 ? statement2-if-true: statement-if-false



**Loops -
        FOR
            for(var i;i<=10;i++) {}

        FOR OF 
            for(const i of arr) console.log(i);
            for(const [index, item] of arr.entries()) console.log(`${index + 1} : ${item}`);         // object is first converted in map using entries method 

        FOR IN
            for(const i in arr) console.log(arr[i]);                        // array
            for(const key in obj){ console.log(`${key} : ${obj[key]}); }      // object

        FOR EACH Method
            - changes done in temporary copy 
            - break/continue can't be used

            arr.forEach(function(item, index, a){console.log(`${item}, ${index}, {$a}`)})                                   // array
            map.forEach(function(value, key, map){console.log(`${key}, ${value}, {$map}`)})                                 // map
            set.forEach(function(item, _, set){console.log(`${item}, {$set}`)})                                             // set
            new Map(Object.entries(obj)).forEach(function(value, key, objMap){console.log(`${key} : ${value} ${objMap}`)})  // object
            nodelist.forEach(function(item, index, a){console.log(`${item}, ${index}, {$a}`)})                              // nodelist
       
        WHILE
            while() {}

        DO-WHILE
            do{
                console.log(a)
                a++
            }while(a<5)



**Functions - Block Scoped in 'use strict' mode
            - Function are just another type of object, function has properties and methods i.e. functionName.name 
            - 'call', 'apply' & 'bind' method can be called on function, i.e. functionName.bind()

        Function statement/declaration - way of creating a function
                function funcName(parameters, a=10, b=a+1) {}           // default parameter            
                                                    
                funcName(arguments, undefined, 100);  // a=1, b=100     // can be called before declaration of function because of hoisting

        Rest operator(...) - for variable number of arguments in form of array
                function funcName(...args) {            // if, x = [1,2,3]   then, ...x = 1, 2, 3   and [ , ...x] = [2, 3]
                    return args.reduce((a,b) => a+b, 0)
                }

                funcName(arguments);  

        Passing Object as arguments
                function funcName(property1, property2) {}          // getting object properties as parameter
                            // if we change the properties in function, obj aslo changes as reference is passed which points to same object
                obj = {property1 : value1, property2 : value2}
                funcName(obj)

        Function Expression - Function acts like a value | can't be called before declaration of function
                var x = function() {}

                x();    
                    // function call, gives error when called before creation as var x is hoisted and assigned with Undefined

        Named Function Expression
                var x = function y() {}

                x();    
                y();                // gives reference error

        Arrow Function - function behaving like a variable, short form for the function definition | 
                            doesn't get argument object and 'this' keyword in their execution context, rather they can use this functionality 
                                                        from their closest normal function parents 'this' keyword
                const gerName = (arg1, arg2) => { }           // const gerNmae = function() {}
                const x = arg => { }

        Anonymous Function - function without name. can have multiple arguments, but only one expression
            
                function() {}           // gives syntax error to fix the error
                (function() {})         // function conerted into expression
                (function() {})()       // when defined this function expression is executed only once

                var greet = function (parameters){            //using function expression; same as greet = (function(p){})
		            console.log(`Welcome to ${parameters}`);        // parameters is function scoped variable
	            }

	            let greet = () => console.log("Welcome to GeeksforGeeks!");         // using arrow function
	            
                greet();            // as we have only one expression in function so we can ignore the {}
                                    // function call, gives error when called before creation as var greet is hoisted and assigned with Undefined

        Self Executing Function/ Immediately Invoked Function - done by converting function into expression then invoking() it
            - Only executed once
            
            (function (parameters){                                                 // converting function into expression
                console.log(`Welcome to ${platform}`);
            })();
            
            (() => {                                                                // using arrow function
                console.log("GeeksforGeeks"); 
            })();

        First class function/citizen 
                - ability to use function as arguments, parameter or returning values for the function

        Higher Order Function - function that receives another function(callback function) as argument that returns a new function(returned function)
                              - only possible because of first-class functions
                eg.              
                    function x(z){                // taking parameter as a function; x is higher order function
                        var a = 7;
                        z();
                        return function {        // returning anonymous function from function x; this anonymous function is returned function
                            console.log(a);
                        }
                    }
                    function y(){ }
                    var r = x(function z(){ });     |
                    var s = x(y)                    |passing function as argument
                    var t = addEventListener("click", function(e){})        // t is Higher Order function and argument function is CallBack function

                map, filter, reduce, addEventListener, parent function in closures 

        Callback function
            setTimeout(function(){}, 2000)      // calls callback fuction after 2000 miliseconds(2 sec)
                        eg. function x() {                  // this function will print 1 after 1 second, 2 after 2 seconds and so on till 5
                                for(let i = 1; i <= 5; i++) {
                                    setTimeout( function () {
                                                                console.log(i);
                                                            }, i*1000);
                                }
                            }
                            x();

        Function Methods - call, apply & bind
            call - to manipulate/modify 'this' value for that function call
                const funcName = obj.fn;         // gives copy of fn() inside of obj to external function(funcName)
                funcName(args);                  // defaultly function call assignes 'this' === undefined (in "use strict")
                funcName.call(objName, args)     // for this function call with 'this' === objName

            apply - to manipulate/modify 'this' value for that function call
                funcName.apply(objName, [args])         // for this function call with 'this' === objName

            bind - returns new function with 'this' value for function, and set it as arguments
                newFunc = funcName.bind(objName, value)     // newFunc.this === objName
                newFunc = funcName.bind(null, value)     // first argument already set(partial application) to value for returned function
                newFunc(arg1)                               // every function call assignes 'this' === objName and arg1 === value   

                document.querySelector('.btn').addEventListener('click', fn)                // defaultly, 'this' === <button class="btn"></button>
                document.querySelector('.btn').addEventListener('click', fn.bind(obj))      // for returned fun, 'this' === obj



**CLOSURES -    Closed-over variable environment(including parameters) of EC in which a function was created 
                        even after that EC is gone or enclosing function has returned
                closure variables takes priority against global variables
                Not accessible outside(Encapsulation)

            function x(){       
                var a = 7;
                function y(){
                    console.log(a);
                }
                y();
                return y;
            }             // Function y() along with its lexical scope(variables/parameters) x() bundles together forms a closure
            var r = x();      // because to closure(x), even after x() is vanished, closure still remembers it for y()
            r();                / will give output as "> 7" 
            console.dir(r)

        Uses of Closures
            - Module design pattern
            - currying
            - Functions like once(function that only executes one time)
            - memorize
            - maintain state in async world
            - setTimeouts
            - Iterators
        
        Advantages of Closures
            - Function currying
            - Data Hiding
            - Encapsulation
            - Module Partition

        Disadvantages of Closures
            - Overconsumption of Memory as closure variables are not garbage collected
            - Memory Leak possibility



**TO access/manipulate DOM - ability to change HTML text, attributes or CSS styles as well as listen and respond to events
    - DOM is very complex API that contain lots of methods(.querySelector(), addEventListener()) and properties(.innerHTML, .textContent) to interact with DOM tree

    +--------------------------------------------------------------------------------------------------------------------+    Example of DOM tree for <a>
    | DOM API                                       +------+    (js object with properties; .textContent,                |          document        |<html>
    |                                               | Node | <-    .childNodes, .parentNode, .cloneNode() )              |              |           |    <body>
    |                    +--------------+-----------+------+----------+-----------------+                                |            <html>        |        <p>
    |                                                                                                               |              |           |            <a>click</a>
    |(inherits all   +-------+       +----+       +-------+       +--------+      +------------+                         |            <body>        |        </p>
    |properties of  |Element|       |Text|       |Comment|       |Document|      |Event Target|  (.addEventListener()  |              |           |    </body>
    |  parent)       +-------+       +----+       +-------+       +--------+      +------------+  .removeEventListener())|             <p>          |</html>
    | eg. .innerHTML <p>,<Button>,   Paragraph   <!--comment-->                                                         |              |   
    |                 <a>, <div>                                                     +------+                            |             <a>
    |                                                                                |Window|   (Global Object, lots of  |
    |                                                                                +------+    methods and properties) |                                                                                                                       
    +--------------------------------------------------------------------------------------------------------------------+
        - 'document' is (1st most/root)node of DOM tree given by web api(browser implemented libraries written in js) that accessed using js

    DOM Events Lifecycle - from the moment webpage first accessed until the user leaves it  
        1. 'DOMContentLoaded' event - fired on document as soon as HTML+JS fetched and conveted into DOM tree finished(excluding img and other external content)
            document.addEventListener('DOMContentLoaded', e => 'HTML parsed and DOM tree built!')

        2. 'load' event - fired on window after all the elements(including img, css and other external content) on webpage are loaded completely
            document.addEventListener('load', e => 'Webpage fully loaded!')

        3. 'beforeunload' event- fired on window just before user is leaving webpage
            document.addEventListener('beforeunload', function(e){
                e.preventDefault();
                e.returnValue = ''          // previously we can give custom messages for leaving conformation(now we have generic message)
            })

    - Selecting and Manipulating web content -

        1. document.getElementById('idName')                   // access the matching first item
        2. document.getElementsByClassName('className')        // returns HTMLColletion, also called as LiveCollection
        3. document.getElementsByTagName('p')                  // returns HTMLColletion, as html dom changes this collection items changes

        4. document.querySelector('cssSelector')       // console.log(document.querySelector(".my-name").textContent);  // only selects first matched element
        5. document.querySelectorAll('cssSelector')    // returns nodelist, doesn't have methods like map()/reduce(). array methods on can be used. Selects all child and deeper elements from the 'document'
                                                            we can convert nodelist(any array like structure) to arrays using Array.from() or [...document.querySelectorAll('cssSelector')]
                eg. console.log(document.querySelector(".my-name").textContent);
                    document.querySelector(".my-name").textContent = `This is text from any tag except input`;

                    console.log(document.querySelector(".my-name").value);      // for input element
                    document.querySelector(".my-name").value


    - Adding/Removing HTML elements
        document.querySelector('p').innerHTML = '';             // removing the inner html of selected <p>
        html = `<p> My name is ${name} </p>`
        document.querySelector('p').insertAdjacentHTML('afterBegin', html)            
                                                        <!-- 'beforebegin' -->
                                                            <p>
                                                                <!-- 'afterbegin' -->
                                                                foo
                                                                <!-- 'beforeend' -->
                                                            </p>
                                                        <!-- 'afterend' -->
        
        document.querySelector('.header').prepend(document.createElement('div').innerHTML('here is buttn <button>Button</button>'))
                                                        <!-- '.before()' -->
                                                            <p class='header'>
                                                                <!-- '.prepend()' -->
                                                                foo
                                                                <!-- '.append()' -->
                                                            </p>
                                                        <!-- '.after()' -->


    - Traversing DOM elements
        - child
            const section = document.querySelector('.section')  // gives first child element node of section no mater how deep-child its on DOM tree
            section.querySelectorAll('.imp')                    // gives nodelist of all matched('.imp') child and deeper child nodes of the section
            section.childNodes                                  // gives nodelist of all direct child nodes(span, text, comment, br, etc.) of the section 
            section.children                                    // gives live HTMLColletion of only html element nodes(span, br) which are direct child of the section
        
        - parent
            section.parentNode                                  // gives direct parent node of the section
            section.parentElement                               // gives direct parent element node of the section
            section.closest('.header')                          // gives closest parent element node of section no matter how far-up parent it's on DOM tree
            section.closest('.section')                         // gives section itself as, section = document.querySelector('.section')
        
        - sibling(only access direct siblings - only consecutive prev and next node)
            section.previousSibling                             // gives direct sibling node that is previous of section, otherwise null
            section.previousElementSibling                      // gives direct sibling element node that is previous of section, otherwise null
            section.nextSibling                                 // gives direct sibling node that is next of section, otherwise null
            section.nextElementSibling                          // gives direct sibling element node that is next of section, otherwise null


    - Changing CSS(applies inline styles)
        document.querySelector('.btnCheck').style.width = '20rem';        // property value should be string including unit
        document.querySelector('body').style.backgroundColor = 'red';     // in css we use background-color but in js we use camelCase 
        
        - to get defined/browser computed styles from webpage
            getComputedStyle(document.querySelector('body'))    => returns object which contains all the styles(defined in style.css / computed by browser)
        
        - to modify CSS Custom properties(variables)
            document.documentElement.style.setProperty('--color-primary', '#34e572')
                        :root{                  // css variables defined on root, accessible throughout all document
                            --color-primary: #4e5678;
                            --color-secondary: #34e572;
                        }
    

    - Manpulating classes of HTML element attributes
        - standard attributes (must have in HTML defined properties)
            document.querySelector('.nav_logo').className   => nav_logo                             | // js will create standard 
            document.querySelector('.nav_logo').src         => http://127.0.0.1:8080/img/logo.png   |  attributes as properties of
            document.querySelector('.nav_logo').alt         => Logo For Navbar                      |  object obj.src, obj.alt, etc.
            document.querySelector('.nav_logo').getAttribute('src')             => img/logo.png
            document.querySelector('.nav_logo').getAttribute('myAttribute')     => my custom defined value for attribute
        
        - non-standard attributes (custom/user-defined attributes)
            document.querySelector('.nav_logo').alt = 'Logo For Navbar'                     
            document.querySelector('.nav_logo').setAttribute('myAttribute', 'my custom defined value for attribute')  

        - data attributes (special attributes stored in dataset object)
            document.querySelector('.nav_logo').dataset.versionNumber   => 3.0        // <img data-version-number="3.0"/>

        - class
            document.querySelector('.nav_logo').className = 'className'    
                // don't use above as it overwrites all present classes and set to only one className
            document.querySelector('p').classList.add('className1', 'className2', 'className3');  
            document.querySelector('p').classList.remove('className1', 'className2', 'className3');  
            document.querySelector('p').classList.replace('className1', 'className2');  
            document.querySelector('p').classList.toggle('className1', i < 10);  
            document.querySelector('p').classList.contains('className1');               => true/false

            let p = document.querySelectorAll('p')              // gives the array of all p elements
            for(let i=0;i < p.length; i++){
                p[i].classList.add('className');
                p[i].addEventListener('click);
            } 


    - Manpulating Viewport/browser window
        document.documentElement.clientHeight           // current height of viewport(brouwser window) in pixels
        document.documentElement.clientWidth            // current width of viewport(brouwser window) in pixels
        x = window.pageXOffset                          // current horizontal scroll location in pixels
        y = window.pageYOffset                          // current vertical scroll location in pixels
        
        s1 = document.querySelector('.section1').getBoundingClientRect()               // returns dom rectangle object(position, width, height,..,etc.) 
        window.scrollTo({left: s1.left + x, top: s1.top + y, behavior: "smooth"})      // left and top will be relative to current viewport, in pixels
        document.querySelector('.section1').scrollIntoView({behavior:"smooth"})      
    
    
    - Handling Events (Event is a signal that is generated by dom node and is generated on document(root node))
        Event happens in 3 stages
            1. Capturing phase  - event goint from root/prarent(document) elements to target element(on which event listener is attached)
            2. Target phase     - event listning and handled(via event handler fnc) from target element(on which event listener is attached)
            3. Bubbling phase   - after event handler function execution, event again goes to root/prarent(document) element, executing handler of parent element(if listener attached)

            Note - defaultly addEventListener() catches event in Bubbling phase.
                 - After target element bubbling can be stopped(event can't be handled by parent elements of target element) using; e.stopPropagation();
                 - to catch event in Capturing phase we can use 3rd argument; addEventListener('click', func, true) 
                 - Event Delegation : attach an event listener to a parent element(using event.target) instead of directly to each child element.
                                    : Event Delegation relies on event bubbling

        const aEventHandlerFnc = (e)=>{}
        a.addEventListener('click', aEventHandlerFnc)       // multiple event handler function can be executed(i.e. a.addEventListener('click', aEventHandlerFnc1), a.addEventListener('click', aEventHandlerFnc2)) // both event handler function will be executed
        a.onClick = aEventHandlerFnc                        // for direct assignment of eventlistener(old), only lastly assigned Event Handler function is executed(i.e. a.addEventListener('click', aEventHandlerFnc1), a.addEventListener('click', aEventHandlerFnc2)) // only aEventHandlerFnc2 is executed     
        <a onclick="aEventHandlerFnc()">Click Here</a>      // html event handler

        a.removeEventListener('click', aEventHandlerFnc) 

        document.querySelector('.btnCheck').addEventListener('click', function(e){ e.preventDefault() })  // eventHandlerFunction(e)
            this === e.currentTarget     // both returns the target element(on which event listener is attached)
            e.target                     // returns the element on which the event is occurred

        Passing 'argument'/changing 'this' keyword value for handler function
            document.querySelector('.btn').addEventListener('click', fn)                // defaultly, 'this' === <button class="btn"></button>
            document.querySelector('.btn').addEventListener('click', fn.bind(obj))      // for returned fun, 'this' === obj

        Intersection Observer API(observe changes of target element intersecting element/viewport)
            const observer = new IntersectionObserver((entries, observer)=>{}, {root: null, threshold: [0,0.1,1], rootMargin:'150px'});    
                                // (entries, observer)=>{observer.unobserve.entry[0].target}
                                // root = element/viewport(null) wrt which target-element is being observed.
                                // threshold = area of root(viewport/element) intersection in % wrt which target-element is being observed
                                                for threshold list, event will trigger at every value from list(as target gets that % area on viewport/element intercepted)
                                // rootMargin = margin to the threshold string value in pixel
            observer.observe(document.querySelector('.section1'))       // target element


    - Handling keyboard events  // global event(should be called on document)
        document.addEventListener('keydown', function(event){       // addEventListener gives the event object which can be used in event handler function
            if (event.key === 'Enter'){}                            // event object will have key property which stores the value of key pressed from the keyboard
        });                                 // 'leftArrow', 'Enter', 'Enter'



**Exception handling

        try{

        } catch(exception){
            console.log(exception)
        }



**Destructuring Operator - short form to assign object property values to the variable
        [y, x] = [x, y]             // swapping values of two variable

        const arr = [1, 2, [3, 4]];
        const [x, , y=0, z=0] = arr;        // x=1, y=[3, 4], z=0       // with default value
        const [x, , [y, z]]                 // x=1, y=3, z=4

        obj = { 
            property1 : {
                property11 : value11,
                property22 : value22
            },
            property2 : value2
        }
        const { property2 } = obj;                                                      // property2 = value2
        ({ property2 } = obj)                                                           // property2 = value2
        const { property2 : x=[], property1 : {property11 : y, property22} } = obj;     // x = value2, y = value11, property22 = value22
        const { property3 : z=[] }                                                      // z = []           // with default value



**New object from object / Class / getter-setter-

        var space = function(planet){
            this.planet = planet;
        }
        var zeus = new space('Earth');       // zeus.planet = 'Earth'

        class space {
            constructor(planet, isWater){
                this.planet = planet;
                this._water = isWater           // private variable - only accessible within the class
            }

            // getter
            get isWater(){
                return this._water
            }

            // setter
            set isWater(updatedStatus){
                this._water = updatedStatus
            }
        }
        var zeus = new space('Earth', true);        // zeus.planet = 'Earth'
        let water_available = zeus.isWater          // getter is called, water_available = true
        zeus.isWater = false                        // setter is called, water_available = false
        water_available = zeus.isWater              // getter is called, water_available = false



**Import/Export - only allows certain function and variables

        import { funcname } from "./fuctionContainer"
        import * as x from "./fuctionContainer"

        export { funcName };
        export const x = 10;